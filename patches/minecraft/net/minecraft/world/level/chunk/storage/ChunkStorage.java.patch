--- a/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -15,33 +_,45 @@
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.structure.LegacyStructureDataHandler;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 
 public class ChunkStorage implements AutoCloseable {
    public static final int LAST_MONOLYTH_STRUCTURE_DATA_VERSION = 1493;
-   private final IOWorker worker;
+   // Paper - nuke IO worker
    protected final DataFixer fixerUpper;
    @Nullable
    private volatile LegacyStructureDataHandler legacyStructureHandler;
+   // Paper start - async chunk loading
+   private final Object persistentDataLock = new Object(); // Paper
+   public final RegionFileStorage regionFileCache;
+   // Paper end - async chunk loading
 
    public ChunkStorage(Path p_196912_, DataFixer p_196913_, boolean p_196914_) {
       this.fixerUpper = p_196913_;
-      this.worker = new IOWorker(p_196912_, p_196914_, "chunk");
+      // Paper start - async chunk io
+      // remove IO worker
+      this.regionFileCache = new RegionFileStorage(p_196912_, p_196914_, true); // Paper - nuke IOWorker // Paper
+      // Paper end - async chunk io
    }
 
    public boolean isOldChunkAround(ChunkPos p_223452_, int p_223453_) {
-      return this.worker.isOldChunkAround(p_223452_, p_223453_);
+      return true; // Paper - (for now, old unoptimised behavior) TODO implement later? the chunk status that blender uses SHOULD already have this radius loaded, no need to go back for it...
    }
 
    public CompoundTag upgradeChunkTag(ResourceKey<Level> p_188289_, Supplier<DimensionDataStorage> p_188290_, CompoundTag p_188291_, Optional<ResourceKey<Codec<? extends ChunkGenerator>>> p_188292_) {
+      p_188291_ = p_188291_.copy(); // Paper - defensive copy, another thread might modify this
+
       int i = getVersion(p_188291_);
       if (i < 1493) {
          p_188291_ = DataFixTypes.CHUNK.update(this.fixerUpper, p_188291_, i, 1493);
          if (p_188291_.getCompound("Level").getBoolean("hasLegacyStructureData")) {
-            LegacyStructureDataHandler legacystructuredatahandler = this.getLegacyStructureHandler(p_188289_, p_188290_);
-            p_188291_ = legacystructuredatahandler.updateFromLegacy(p_188291_);
+            synchronized (this.persistentDataLock) {  // Paper - Async chunk loading
+               LegacyStructureDataHandler legacystructuredatahandler = this.getLegacyStructureHandler(p_188289_, p_188290_);
+               p_188291_ = legacystructuredatahandler.updateFromLegacy(p_188291_);
+            }  // Paper - Async chunk loading
          }
       }
 
@@ -58,7 +_,7 @@
    private LegacyStructureDataHandler getLegacyStructureHandler(ResourceKey<Level> p_223449_, Supplier<DimensionDataStorage> p_223450_) {
       LegacyStructureDataHandler legacystructuredatahandler = this.legacyStructureHandler;
       if (legacystructuredatahandler == null) {
-         synchronized(this) {
+         synchronized(this.persistentDataLock) { // Paper - async chunk loading
             legacystructuredatahandler = this.legacyStructureHandler;
             if (legacystructuredatahandler == null) {
                this.legacyStructureHandler = legacystructuredatahandler = LegacyStructureDataHandler.getLegacyStructureHandler(p_223449_, p_223450_.get());
@@ -82,27 +_,58 @@
       return NbtUtils.getDataVersion(p_63506_, -1);
    }
 
-   public CompletableFuture<Optional<CompoundTag>> read(ChunkPos p_223455_) {
-      return this.worker.loadAsync(p_223455_);
-   }
-
-   public void write(ChunkPos p_63503_, CompoundTag p_63504_) {
-      this.worker.store(p_63503_, p_63504_);
+   public CompletableFuture<Optional<CompoundTag>> read(ChunkPos chunkPos) {
+      // Paper start - async chunk io
+      try {
+         return CompletableFuture.completedFuture(Optional.ofNullable(this.readSync(chunkPos)));
+      } catch (Throwable thr) {
+         return CompletableFuture.failedFuture(thr);
+      }
+   }
+   @Nullable
+   public CompoundTag readSync(ChunkPos chunkPos) throws IOException {
+      return this.regionFileCache.read(chunkPos);
+   }
+   // Paper end - async chunk io
+
+
+   // Paper start - async chunk io
+   public void write(ChunkPos chunkPos, CompoundTag nbt) throws IOException {
+      // Paper start
+      if (nbt != null && !chunkPos.equals(ChunkSerializer.getChunkCoordinate(nbt))) {
+         String world = (this instanceof net.minecraft.server.level.ChunkMap) ? ((net.minecraft.server.level.ChunkMap)this).level.dimension().toString() : null;
+         throw new IllegalArgumentException("Chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + chunkPos.toString()
+                 + " but compound says coordinate is " + ChunkSerializer.getChunkCoordinate(nbt).toString() + (world == null ? " for an unknown world" : (" for world: " + world)));
+      }
+      // Paper end
+      this.regionFileCache.write(chunkPos, nbt);
+      // Paper end - Async chunk loading
       if (this.legacyStructureHandler != null) {
-         this.legacyStructureHandler.removeIndex(p_63503_.toLong());
+         synchronized (this.persistentDataLock) { // Paper - Async chunk loading
+            this.legacyStructureHandler.removeIndex(chunkPos.toLong());
+         } // Paper - Async chunk loading
       }
 
    }
 
    public void flushWorker() {
-      this.worker.synchronize(true).join();
+      io.papermc.paper.chunk.system.io.RegionFileIOThread.flush(); // Paper - rewrite chunk system
    }
 
    public void close() throws IOException {
-      this.worker.close();
+      this.regionFileCache.close(); // Paper - nuke IO worker
    }
 
    public ChunkScanAccess chunkScanner() {
-      return this.worker;
+      // Paper start - nuke IO worker
+      return ((chunkPos, streamTagVisitor) -> {
+         try {
+            this.regionFileCache.scanChunk(chunkPos, streamTagVisitor);
+            return java.util.concurrent.CompletableFuture.completedFuture(null);
+         } catch (IOException e) {
+            throw new RuntimeException(e);
+         }
+      });
+      // Paper end
    }
 }
