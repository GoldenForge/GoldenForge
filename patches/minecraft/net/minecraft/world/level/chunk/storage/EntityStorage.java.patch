--- a/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -30,42 +_,30 @@
    private static final String ENTITIES_TAG = "Entities";
    private static final String POSITION_TAG = "Position";
    private final ServerLevel level;
-   private final IOWorker worker;
+   // Paper - rewrite chunk system
    private final LongSet emptyChunks = new LongOpenHashSet();
-   private final ProcessorMailbox<Runnable> entityDeserializerQueue;
+   // Paper - rewrite chunk system
    protected final DataFixer fixerUpper;
 
    public EntityStorage(ServerLevel p_196924_, Path p_196925_, DataFixer p_196926_, boolean p_196927_, Executor p_196928_) {
       this.level = p_196924_;
       this.fixerUpper = p_196926_;
-      this.entityDeserializerQueue = ProcessorMailbox.create(p_196928_, "entity-deserializer");
-      this.worker = new IOWorker(p_196925_, p_196927_, "entities");
+      // Paper - rewrite chunk system
    }
 
    public CompletableFuture<ChunkEntities<Entity>> loadEntities(ChunkPos p_156551_) {
-      return this.emptyChunks.contains(p_156551_.toLong()) ? CompletableFuture.completedFuture(emptyChunk(p_156551_)) : this.worker.loadAsync(p_156551_).thenApplyAsync((p_223458_) -> {
-         if (p_223458_.isEmpty()) {
-            this.emptyChunks.add(p_156551_.toLong());
-            return emptyChunk(p_156551_);
-         } else {
-            try {
-               ChunkPos chunkpos = readChunkPos(p_223458_.get());
-               if (!Objects.equals(p_156551_, chunkpos)) {
-                  LOGGER.error("Chunk file at {} is in the wrong location. (Expected {}, got {})", p_156551_, p_156551_, chunkpos);
-               }
-            } catch (Exception exception) {
-               LOGGER.warn("Failed to parse chunk {} position info", p_156551_, exception);
-            }
-
-            CompoundTag compoundtag = this.upgradeChunkTag(p_223458_.get());
-            ListTag listtag = compoundtag.getList("Entities", 10);
-            List<Entity> list = EntityType.loadEntitiesRecursive(listtag, this.level).collect(ImmutableList.toImmutableList());
-            return new ChunkEntities<>(p_156551_, list);
-         }
-      }, this.entityDeserializerQueue::tell);
-   }
-
-   private static ChunkPos readChunkPos(CompoundTag p_156571_) {
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system - copy out read logic into readEntities
+   }
+
+   // Paper start - rewrite chunk system
+   public static List<Entity> readEntities(ServerLevel level, CompoundTag compoundTag) {
+      ListTag listTag = compoundTag.getList("Entities", 10);
+      List<Entity> list = EntityType.loadEntitiesRecursive(listTag, level).collect(ImmutableList.toImmutableList());
+      return list;
+   }
+   // Paper end - rewrite chunk system
+
+   public static ChunkPos readChunkPos(CompoundTag p_156571_) { // Paper - public
       int[] aint = p_156571_.getIntArray("Position");
       return new ChunkPos(aint[0], aint[1]);
    }
@@ -79,43 +_,84 @@
    }
 
    public void storeEntities(ChunkEntities<Entity> p_156559_) {
-      ChunkPos chunkpos = p_156559_.getPos();
+      // Paper start - rewrite chunk system
+      if (true) {
+         throw new UnsupportedOperationException();
+      }
+      // Paper end - rewrite chunk system
+      ChunkPos chunkPos = p_156559_.getPos();
       if (p_156559_.isEmpty()) {
-         if (this.emptyChunks.add(chunkpos.toLong())) {
-            this.worker.store(chunkpos, (CompoundTag)null);
+         if (this.emptyChunks.add(chunkPos.toLong())) {
+            // Paper - rewrite chunk system
          }
 
       } else {
-         ListTag listtag = new ListTag();
-         p_156559_.getEntities().forEach((p_156567_) -> {
-            CompoundTag compoundtag1 = new CompoundTag();
-            if (p_156567_.save(compoundtag1)) {
-               listtag.add(compoundtag1);
-            }
-
-         });
-         CompoundTag compoundtag = NbtUtils.addCurrentDataVersion(new CompoundTag());
-         compoundtag.put("Entities", listtag);
-         writeChunkPos(compoundtag, chunkpos);
-         this.worker.store(chunkpos, compoundtag).exceptionally((p_156554_) -> {
-            LOGGER.error("Failed to store chunk {}", chunkpos, p_156554_);
-            return null;
-         });
-         this.emptyChunks.remove(chunkpos.toLong());
-      }
-   }
+         // Paper - move into saveEntityChunk0
+         this.emptyChunks.remove(chunkPos.toLong());
+      }
+   }
+
+   // Paper start - rewrite chunk system
+   public static void copyEntities(final CompoundTag from, final CompoundTag into) {
+      if (from == null) {
+         return;
+      }
+      final ListTag entitiesFrom = from.getList("Entities", net.minecraft.nbt.Tag.TAG_COMPOUND);
+      if (entitiesFrom == null || entitiesFrom.isEmpty()) {
+         return;
+      }
+
+      final ListTag entitiesInto = into.getList("Entities", net.minecraft.nbt.Tag.TAG_COMPOUND);
+      into.put("Entities", entitiesInto); // this is in case into doesn't have any entities
+      entitiesInto.addAll(0, entitiesFrom.copy()); // need to copy, this is coming from the save thread
+   }
+
+   public static CompoundTag saveEntityChunk(List<Entity> entities, ChunkPos chunkPos, ServerLevel level) {
+      return saveEntityChunk0(entities, chunkPos, level, false);
+   }
+   private static CompoundTag saveEntityChunk0(List<Entity> entities, ChunkPos chunkPos, ServerLevel level, boolean force) {
+      if (!force && entities.isEmpty()) {
+         return null;
+      }
+
+      ListTag listTag = new ListTag();
+      final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
+      entities.forEach((entity) -> { // diff here: use entities parameter
+         // Paper start
+         final EntityType<?> entityType = entity.getType();
+//         final int saveLimit = level.paperConfig().chunks.entityPerChunkSaveLimit.getOrDefault(entityType, -1);
+//         if (saveLimit > -1) {
+//            if (savedEntityCounts.getOrDefault(entityType, 0) >= saveLimit) {
+//               return;
+//            }
+//            savedEntityCounts.merge(entityType, 1, Integer::sum);
+//         }
+         // Paper end
+         CompoundTag compoundTag = new CompoundTag();
+         if (entity.save(compoundTag)) {
+            listTag.add(compoundTag);
+         }
+
+      });
+      CompoundTag compoundTag = NbtUtils.addCurrentDataVersion(new CompoundTag());
+      compoundTag.put("Entities", listTag);
+      writeChunkPos(compoundTag, chunkPos);
+      // Paper - remove worker usage
+
+      return !force && listTag.isEmpty() ? null : compoundTag;
+   }
+   // Paper end - rewrite chunk system
 
    public void flush(boolean p_182487_) {
-      this.worker.synchronize(p_182487_).join();
-      this.entityDeserializerQueue.runAll();
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
-   private CompoundTag upgradeChunkTag(CompoundTag p_156573_) {
+   public static CompoundTag upgradeChunkTag(CompoundTag p_156573_) { // Paper - public and static
       int i = NbtUtils.getDataVersion(p_156573_, -1);
-      return DataFixTypes.ENTITY_CHUNK.updateToCurrentVersion(this.fixerUpper, p_156573_, i);
+      return ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ENTITY_CHUNK, p_156573_, i, net.minecraft.SharedConstants.getCurrentVersion().getDataVersion().getVersion()); // Paper - route to new converter system
    }
 
    public void close() throws IOException {
-      this.worker.close();
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 }
