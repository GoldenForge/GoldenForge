--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -8,54 +_,42 @@
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-   private Int2ObjectMap<Entity> active = new Int2ObjectLinkedOpenHashMap<>();
-   private Int2ObjectMap<Entity> passive = new Int2ObjectLinkedOpenHashMap<>();
-   @Nullable
-   private Int2ObjectMap<Entity> iterated;
+   private final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking?
 
    private void ensureActiveIsNotIterated() {
-      if (this.iterated == this.active) {
-         this.passive.clear();
-
-         for(Int2ObjectMap.Entry<Entity> entry : Int2ObjectMaps.fastIterable(this.active)) {
-            this.passive.put(entry.getIntKey(), entry.getValue());
-         }
-
-         Int2ObjectMap<Entity> int2objectmap = this.active;
-         this.active = this.passive;
-         this.passive = int2objectmap;
-      }
-
-   }
-
-   public void add(Entity p_156909_) {
-      this.ensureActiveIsNotIterated();
-      this.active.put(p_156909_.getId(), p_156909_);
-   }
-
-   public void remove(Entity p_156913_) {
-      this.ensureActiveIsNotIterated();
-      this.active.remove(p_156913_.getId());
-   }
-
-   public boolean contains(Entity p_156915_) {
-      return this.active.containsKey(p_156915_.getId());
-   }
-
-   public void forEach(Consumer<Entity> p_156911_) {
-      if (this.iterated != null) {
-         throw new UnsupportedOperationException("Only one concurrent iteration supported");
-      } else {
-         this.iterated = this.active;
-
-         try {
-            for(Entity entity : this.active.values()) {
-               p_156911_.accept(entity);
-            }
-         } finally {
-            this.iterated = null;
-         }
-
-      }
+      // Paper - replace with better logic, do not delay removals
+
+   }
+
+   public void add(Entity entity) {
+      io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist addition"); // Paper
+      this.ensureActiveIsNotIterated();
+      this.entities.add(entity); // Paper - replace with better logic, do not delay removals/additions
+   }
+
+   public void remove(Entity entity) {
+      io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist removal"); // Paper
+      this.ensureActiveIsNotIterated();
+      this.entities.remove(entity); // Paper - replace with better logic, do not delay removals/additions
+   }
+
+   public boolean contains(Entity entity) {
+      return this.entities.contains(entity); // Paper - replace with better logic, do not delay removals/additions
+   }
+
+   public void forEach(Consumer<Entity> action) {
+      io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist iteration"); // Paper
+      // Paper start - replace with better logic, do not delay removals/additions
+      // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
+      // (by dfl iterator() is configured to not iterate over new entries)
+      io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+      try {
+         while (iterator.hasNext()) {
+            action.accept(iterator.next());
+         }
+      } finally {
+         iterator.finishedIterating();
+      }
+      // Paper end - replace with better logic, do not delay removals/additions
    }
 }
