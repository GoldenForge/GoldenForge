--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -26,6 +_,7 @@
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.util.AbortableIterationConsumer;
@@ -70,7 +_,7 @@
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.Scoreboard;
 
-public abstract class Level implements LevelAccessor, AutoCloseable {
+public abstract class Level extends net.minecraftforge.common.capabilities.CapabilityProvider<Level> implements LevelAccessor, AutoCloseable, net.minecraftforge.common.extensions.IForgeLevel {
    public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
    public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("overworld"));
    public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("the_nether"));
@@ -110,8 +_,38 @@
    private final RegistryAccess registryAccess;
    private final DamageSources damageSources;
    private long subTickCount;
+   public boolean restoringBlockSnapshots = false;
+   public boolean captureBlockSnapshots = false;
+   public java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<>();
+   private final java.util.ArrayList<BlockEntity> freshBlockEntities = new java.util.ArrayList<>();
+   private final java.util.ArrayList<BlockEntity> pendingFreshBlockEntities = new java.util.ArrayList<>();
+
+   public final ChunkAccess getChunkIfLoadedImmediately(int x, int z) {
+      return ((ServerLevel)this).chunkSource.getChunkAtIfLoadedImmediately(x, z);
+   }
+
+   public WorldPaper getWorld() {
+      return worldPaper;
+   }
+
+   WorldPaper worldPaper = new WorldPaper();
+   public class WorldPaper {
+
+      public String getName() {
+         return Level.this.dimension().location().toString();
+      }
+   }
+
+   public @Nullable LevelChunk getChunkIfLoaded(int x, int z) { // Overridden in WorldServer for ABI compat which has final
+      return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(x, z);
+   }
+   public final @Nullable LevelChunk getChunkIfLoaded(BlockPos blockposition) {
+      return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+   }
+
 
    protected Level(WritableLevelData p_270739_, ResourceKey<Level> p_270683_, RegistryAccess p_270200_, Holder<DimensionType> p_270240_, Supplier<ProfilerFiller> p_270692_, boolean p_270904_, boolean p_270470_, long p_270248_, int p_270466_) {
+      super(Level.class);
       this.profiler = p_270692_;
       this.levelData = p_270739_;
       this.dimensionTypeRegistration = p_270240_;
@@ -198,18 +_,52 @@
       } else {
          LevelChunk levelchunk = this.getChunkAt(p_46605_);
          Block block = p_46606_.getBlock();
+
+         p_46605_ = p_46605_.immutable(); // Forge - prevent mutable BlockPos leaks
+         net.minecraftforge.common.util.BlockSnapshot blockSnapshot = null;
+         if (this.captureBlockSnapshots && !this.isClientSide) {
+             blockSnapshot = net.minecraftforge.common.util.BlockSnapshot.create(this.dimension, this, p_46605_, p_46607_);
+             this.capturedBlockSnapshots.add(blockSnapshot);
+         }
+
+         BlockState old = getBlockState(p_46605_);
+         int oldLight = old.getLightEmission(this, p_46605_);
+         int oldOpacity = old.getLightBlock(this, p_46605_);
+
          BlockState blockstate = levelchunk.setBlockState(p_46605_, p_46606_, (p_46607_ & 64) != 0);
          if (blockstate == null) {
+            if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
             return false;
          } else {
             BlockState blockstate1 = this.getBlockState(p_46605_);
+
+            if (blockSnapshot == null) { // Don't notify clients or update physics while capturing blockstates
+               this.markAndNotifyBlock(p_46605_, levelchunk, blockstate, p_46606_, p_46607_, p_46608_);
+            }
+
+            return true;
+         }
+      }
+   }
+
+   // Split off from original setBlockState(BlockPos, BlockState, int, int) method in order to directly send client and physic updates
+   public void markAndNotifyBlock(BlockPos p_46605_, @Nullable LevelChunk levelchunk, BlockState blockstate, BlockState p_46606_, int p_46607_, int p_46608_) {
+      Block block = p_46606_.getBlock();
+      BlockState blockstate1 = getBlockState(p_46605_);
+      {
+         {
             if (blockstate1 == p_46606_) {
                if (blockstate != blockstate1) {
                   this.setBlocksDirty(p_46605_, blockstate, blockstate1);
                }
 
-               if ((p_46607_ & 2) != 0 && (!this.isClientSide || (p_46607_ & 4) == 0) && (this.isClientSide || levelchunk.getFullStatus() != null && levelchunk.getFullStatus().isOrAfter(FullChunkStatus.BLOCK_TICKING))) {
+               if ((p_46607_ & 2) != 0 && (!this.isClientSide || (p_46607_ & 4) == 0) && (this.isClientSide || levelchunk == null || (levelchunk.getFullStatus() != null && levelchunk.getFullStatus().isOrAfter(FullChunkStatus.BLOCK_TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
                   this.sendBlockUpdated(p_46605_, blockstate, p_46606_, p_46607_);
+                  // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
+                  // if copied from above
+               } else if ((p_46607_ & 2) != 0 && (!this.isClientSide || (p_46607_ & 4) == 0)) { // Paper - replace old player chunk management
+                  ((ServerLevel)this).getChunkSource().blockChanged(p_46605_);
+                  // Paper end - per player view distance
                }
 
                if ((p_46607_ & 1) != 0) {
@@ -227,9 +_,8 @@
                }
 
                this.onBlockStateChange(p_46605_, blockstate, blockstate1);
+               p_46606_.onBlockStateChange(this, p_46605_, blockstate);
             }
-
-            return true;
          }
       }
    }
@@ -279,6 +_,7 @@
    }
 
    public void updateNeighborsAt(BlockPos p_46673_, Block p_46674_) {
+      net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, p_46673_, this.getBlockState(p_46673_), java.util.EnumSet.allOf(Direction.class), false).isCanceled();
    }
 
    public void updateNeighborsAtExceptFromFacing(BlockPos p_46591_, Block p_46592_, Direction p_46593_) {
@@ -398,10 +_,26 @@
       (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(p_151526_);
    }
 
+   public void addFreshBlockEntities(java.util.Collection<BlockEntity> beList) {
+      if (this.tickingBlockEntities) {
+         this.pendingFreshBlockEntities.addAll(beList);
+      } else {
+         this.freshBlockEntities.addAll(beList);
+      }
+   }
+
    protected void tickBlockEntities() {
       ProfilerFiller profilerfiller = this.getProfiler();
       profilerfiller.push("blockEntities");
+      if (!this.pendingFreshBlockEntities.isEmpty()) {
+         this.freshBlockEntities.addAll(this.pendingFreshBlockEntities);
+         this.pendingFreshBlockEntities.clear();
+      }
       this.tickingBlockEntities = true;
+      if (!this.freshBlockEntities.isEmpty()) {
+         this.freshBlockEntities.forEach(BlockEntity::onLoad);
+         this.freshBlockEntities.clear();
+      }
       if (!this.pendingBlockEntityTickers.isEmpty()) {
          this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
          this.pendingBlockEntityTickers.clear();
@@ -424,12 +_,19 @@
 
    public <T extends Entity> void guardEntityTick(Consumer<T> p_46654_, T p_46655_) {
       try {
+         net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(p_46655_);
          p_46654_.accept(p_46655_);
       } catch (Throwable throwable) {
          CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking entity");
          CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being ticked");
          p_46655_.fillCrashReportCategory(crashreportcategory);
+         if (net.minecraftforge.common.ForgeConfig.SERVER.removeErroringEntities.get()) {
+            com.mojang.logging.LogUtils.getLogger().error("{}", crashreport.getFriendlyReport());
+            p_46655_.discard();
+         } else
          throw new ReportedException(crashreport);
+      } finally {
+         net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(p_46655_);
       }
    }
 
@@ -471,7 +_,7 @@
             explosion$blockinteraction1 = this.getDestroyType(GameRules.RULE_BLOCK_EXPLOSION_DROP_DECAY);
             break;
          case MOB:
-            explosion$blockinteraction1 = this.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) ? this.getDestroyType(GameRules.RULE_MOB_EXPLOSION_DROP_DECAY) : Explosion.BlockInteraction.KEEP;
+            explosion$blockinteraction1 = net.minecraftforge.event.ForgeEventFactory.getMobGriefingEvent(this, p_256233_) ? this.getDestroyType(GameRules.RULE_MOB_EXPLOSION_DROP_DECAY) : Explosion.BlockInteraction.KEEP;
             break;
          case TNT:
             explosion$blockinteraction1 = this.getDestroyType(GameRules.RULE_TNT_EXPLOSION_DROP_DECAY);
@@ -482,6 +_,7 @@
 
       Explosion.BlockInteraction explosion$blockinteraction = explosion$blockinteraction1;
       Explosion explosion = new Explosion(this, p_256233_, p_255861_, p_255867_, p_256447_, p_255732_, p_255717_, p_256013_, p_256228_, explosion$blockinteraction);
+      if (net.minecraftforge.event.ForgeEventFactory.onExplosionStart(this, explosion)) return explosion;
       explosion.explode();
       explosion.finalizeExplosion(p_256377_);
       return explosion;
@@ -498,7 +_,7 @@
       if (this.isOutsideBuildHeight(p_46716_)) {
          return null;
       } else {
-         return !this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(p_46716_).getBlockEntity(p_46716_, LevelChunk.EntityCreationType.IMMEDIATE);
+         return !this.isClientSide && !io.papermc.paper.util.TickThread.isTickThread() ? null : this.getChunkAt(p_46716_).getBlockEntity(p_46716_, LevelChunk.EntityCreationType.IMMEDIATE);
       }
    }
 
@@ -513,6 +_,7 @@
       if (!this.isOutsideBuildHeight(p_46748_)) {
          this.getChunkAt(p_46748_).removeBlockEntity(p_46748_);
       }
+      this.updateNeighbourForOutputSignal(p_46748_, getBlockState(p_46748_).getBlock()); //Notify neighbors of changes
    }
 
    public boolean isLoaded(BlockPos p_46750_) {
@@ -578,20 +_,7 @@
    public List<Entity> getEntities(@Nullable Entity p_46536_, AABB p_46537_, Predicate<? super Entity> p_46538_) {
       this.getProfiler().incrementCounter("getEntities");
       List<Entity> list = Lists.newArrayList();
-      this.getEntities().get(p_46537_, (p_151522_) -> {
-         if (p_151522_ != p_46536_ && p_46538_.test(p_151522_)) {
-            list.add(p_151522_);
-         }
-
-         if (p_151522_ instanceof EnderDragon) {
-            for(EnderDragonPart enderdragonpart : ((EnderDragon)p_151522_).getSubEntities()) {
-               if (p_151522_ != p_46536_ && p_46538_.test(enderdragonpart)) {
-                  list.add(enderdragonpart);
-               }
-            }
-         }
-
-      });
+      ((ServerLevel)this).getEntityLookup().getEntities(p_46536_, p_46537_, list, p_46538_); // Paper - optimise this call
       return list;
    }
 
@@ -607,28 +_,23 @@
 
    public <T extends Entity> void getEntities(EntityTypeTest<Entity, T> p_261885_, AABB p_262086_, Predicate<? super T> p_261688_, List<? super T> p_262071_, int p_261858_) {
       this.getProfiler().incrementCounter("getEntities");
-      this.getEntities().get(p_261885_, p_262086_, (p_261454_) -> {
-         if (p_261688_.test(p_261454_)) {
-            p_262071_.add(p_261454_);
-            if (p_262071_.size() >= p_261858_) {
-               return AbortableIterationConsumer.Continuation.ABORT;
-            }
-         }
-
-         if (p_261454_ instanceof EnderDragon enderdragon) {
-            for(EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
-               T t = p_261885_.tryCast(enderdragonpart);
-               if (t != null && p_261688_.test(t)) {
-                  p_262071_.add(t);
-                  if (p_262071_.size() >= p_261858_) {
-                     return AbortableIterationConsumer.Continuation.ABORT;
-                  }
-               }
-            }
-         }
-
-         return AbortableIterationConsumer.Continuation.CONTINUE;
-      });
+      // Paper start - optimise this call
+      //TODO use limit
+      if (p_261885_ instanceof net.minecraft.world.entity.EntityType entityTypeTest) {
+         ((ServerLevel) this).getEntityLookup().getEntities(entityTypeTest, p_262086_, p_262071_, p_261688_);
+      } else {
+         Predicate<? super T> test = (obj) -> {
+            return p_261885_.tryCast(obj) != null;
+         };
+         p_261688_ = p_261688_ == null ? test : test.and((Predicate) p_261688_);
+         Class base;
+         if (p_261885_ == null || (base = p_261885_.getBaseClass()) == null || base == Entity.class) {
+            ((ServerLevel) this).getEntityLookup().getEntities((Entity) null, p_262086_, (List) p_262071_, (Predicate)p_261688_);
+         } else {
+            ((ServerLevel) this).getEntityLookup().getEntities(base, null, p_262086_, (List) p_262071_, (Predicate)p_261688_); // Paper - optimise this call
+         }
+      }
+      // Paper end - optimise this call
    }
 
    @Nullable
@@ -760,16 +_,15 @@
    public abstract Scoreboard getScoreboard();
 
    public void updateNeighbourForOutputSignal(BlockPos p_46718_, Block p_46719_) {
-      for(Direction direction : Direction.Plane.HORIZONTAL) {
+      for(Direction direction : Direction.values()) {
          BlockPos blockpos = p_46718_.relative(direction);
          if (this.hasChunkAt(blockpos)) {
             BlockState blockstate = this.getBlockState(blockpos);
-            if (blockstate.is(Blocks.COMPARATOR)) {
-               this.neighborChanged(blockstate, blockpos, p_46719_, p_46718_, false);
-            } else if (blockstate.isRedstoneConductor(this, blockpos)) {
+            blockstate.onNeighborChange(this, blockpos, p_46718_);
+            if (blockstate.isRedstoneConductor(this, blockpos)) {
                blockpos = blockpos.relative(direction);
                blockstate = this.getBlockState(blockpos);
-               if (blockstate.is(Blocks.COMPARATOR)) {
+               if (blockstate.getWeakChanges(this, blockpos)) {
                   this.neighborChanged(blockstate, blockpos, p_46719_, p_46718_, false);
                }
             }
@@ -854,6 +_,18 @@
 
    public BiomeManager getBiomeManager() {
       return this.biomeManager;
+   }
+
+   private double maxEntityRadius = 2.0D;
+   @Override
+   public double getMaxEntityRadius() {
+      return maxEntityRadius;
+   }
+   @Override
+   public double increaseMaxEntityRadius(double value) {
+      if (value > maxEntityRadius)
+         maxEntityRadius = value;
+      return maxEntityRadius;
    }
 
    public final boolean isDebug() {
