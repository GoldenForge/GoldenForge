--- a/net/minecraft/server/level/ChunkHolder.java
+++ b/net/minecraft/server/level/ChunkHolder.java
@@ -43,17 +_,12 @@
    private static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> NOT_DONE_YET = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
    private static final CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> UNLOADED_LEVEL_CHUNK_FUTURE = CompletableFuture.completedFuture(UNLOADED_LEVEL_CHUNK);
    private static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
-   private final AtomicReferenceArray<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> futures = new AtomicReferenceArray<>(CHUNK_STATUSES.size());
+   // Paper - rewrite chunk system
    private final LevelHeightAccessor levelHeightAccessor;
-   private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> fullChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-   private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> tickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-   private volatile CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> entityTickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-   private CompletableFuture<ChunkAccess> chunkToSave = CompletableFuture.completedFuture((ChunkAccess)null);
+   // Paper - rewrite chunk system
    @Nullable
    private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory = null;
-   private int oldTicketLevel;
-   private int ticketLevel;
-   private int queueLevel;
+   // Paper - rewrite chunk system
    final ChunkPos pos;
    private boolean hasChangedSections;
    private final ShortSet[] changedBlocksPerSection;
@@ -62,106 +_,182 @@
    private final LevelLightEngine lightEngine;
    private final ChunkHolder.LevelChangeListener onLevelChange;
    private final ChunkHolder.PlayerProvider playerProvider;
-   private boolean wasAccessibleSinceLastSave;
-   private CompletableFuture<Void> pendingFullStateConfirmation = CompletableFuture.completedFuture((Void)null);
-   private CompletableFuture<?> sendSync = CompletableFuture.completedFuture((Object)null);
-
-   public ChunkHolder(ChunkPos p_142986_, int p_142987_, LevelHeightAccessor p_142988_, LevelLightEngine p_142989_, ChunkHolder.LevelChangeListener p_142990_, ChunkHolder.PlayerProvider p_142991_) {
+   // Paper - rewrite chunk system
+
+   private final ChunkMap chunkMap; // Paper
+   // Paper start - no-tick view distance
+   public final LevelChunk getSendingChunk() {
+      // it's important that we use getChunkAtIfLoadedImmediately to mirror the chunk sending logic used
+      // in Chunk's neighbour callback
+      LevelChunk ret = this.chunkMap.level.getChunkSource().getChunkAtIfLoadedImmediately(this.pos.x, this.pos.z);
+      if (ret != null && ret.areNeighboursLoaded(1)) {
+         return ret;
+      }
+      return null;
+   }
+
+   // Paper start - optimise chunk tick iteration
+   public final boolean needsBroadcastChanges() {
+      return this.hasChangedSections || !this.skyChangedLightSectionFilter.isEmpty() || !this.blockChangedLightSectionFilter.isEmpty();
+   }
+
+   private void addToBroadcastMap() {
+      io.papermc.paper.util.TickThread.ensureTickThread(this.chunkMap.level, this.pos, "Asynchronous ChunkHolder update is not allowed");
+      this.chunkMap.needsChangeBroadcasting.add(this);
+   }
+   // Paper end - optimise chunk tick iteration
+
+   public void onChunkAdd() {
+      // Paper start - optimise chunk tick iteration
+      if (this.needsBroadcastChanges()) {
+         this.chunkMap.needsChangeBroadcasting.add(this);
+      }
+      // Paper end - optimise chunk tick iteration
+   }
+
+   public void onChunkRemove() {
+      // Paper start - optimise chunk tick iteration
+      if (this.needsBroadcastChanges()) {
+         this.chunkMap.needsChangeBroadcasting.remove(this);
+      }
+      // Paper end - optimise chunk tick iteration
+   }
+   // Paper end
+   // Paper end - no-tick view distance
+   public final io.papermc.paper.chunk.system.scheduling.NewChunkHolder newChunkHolder; // Paper - rewrite chunk system
+   // Paper start - replace player chunk loader
+   private final com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersSentChunkTo = new com.destroystokyo.paper.util.maplist.ReferenceList<>();
+
+   public void addPlayer(ServerPlayer player) {
+      if (!this.playersSentChunkTo.add(player)) {
+         throw new IllegalStateException("Already sent chunk " + this.pos + " in world '" + this.chunkMap.level.getWorld().getName() + "' to player " + player);
+      }
+   }
+
+   public void removePlayer(ServerPlayer player) {
+      if (!this.playersSentChunkTo.remove(player)) {
+         throw new IllegalStateException("Have not sent chunk " + this.pos + " in world '" + this.chunkMap.level.getWorld().getName() + "' to player " + player);
+      }
+   }
+
+   public boolean hasChunkBeenSent() {
+      return this.playersSentChunkTo.size() != 0;
+   }
+
+   public boolean hasBeenSent(ServerPlayer to) {
+      return this.playersSentChunkTo.contains(to);
+   }
+   // Paper end - replace player chunk loader
+
+   public ChunkHolder(ChunkPos p_142986_, LevelHeightAccessor p_142988_, LevelLightEngine p_142989_, ChunkHolder.PlayerProvider p_142991_,  io.papermc.paper.chunk.system.scheduling.NewChunkHolder newChunkHolder) { // Paper - rewrite chunk system
+      this.newChunkHolder = newChunkHolder; // Paper - rewrite chunk system
       this.pos = p_142986_;
       this.levelHeightAccessor = p_142988_;
       this.lightEngine = p_142989_;
-      this.onLevelChange = p_142990_;
+      this.onLevelChange = null; // Paper - rewrite chunk system
       this.playerProvider = p_142991_;
-      this.oldTicketLevel = ChunkLevel.MAX_LEVEL + 1;
-      this.ticketLevel = this.oldTicketLevel;
-      this.queueLevel = this.oldTicketLevel;
-      this.setTicketLevel(p_142987_);
+      // Paper - rewrite chunk system
       this.changedBlocksPerSection = new ShortSet[p_142988_.getSectionsCount()];
+      this.chunkMap = (ChunkMap)p_142991_; // Paper
+   }
+
+   // Paper start
+   public @Nullable ChunkAccess getAvailableChunkNow() {
+      return this.newChunkHolder.getCurrentChunk(); // Paper - rewrite chunk system
+   }
+   // Paper end
+
+   public LevelChunk getFullChunkNow() {
+      // Paper start - rewrite chunk system
+      ChunkAccess chunk = this.getAvailableChunkNow();
+      if (!this.isFullChunkReady() || !(chunk instanceof LevelChunk)) return null; // instanceof to avoid a race condition on off-main threads
+      return (LevelChunk)chunk;
+      // Paper end - rewrite chunk system
+   }
+
+   public LevelChunk getFullChunkNowUnchecked() {
+      // Paper start - rewrite chunk system
+      ChunkAccess chunk = this.getAvailableChunkNow();
+      return chunk instanceof LevelChunk ? (LevelChunk)chunk : null;
+      // Paper end - rewrite chunk system
    }
 
    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresentUnchecked(ChunkStatus p_140048_) {
-      CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.futures.get(p_140048_.getIndex());
-      return completablefuture == null ? UNLOADED_CHUNK_FUTURE : completablefuture;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getFutureIfPresent(ChunkStatus p_140081_) {
-      return ChunkLevel.generationStatus(this.ticketLevel).isOrAfter(p_140081_) ? this.getFutureIfPresentUnchecked(p_140081_) : UNLOADED_CHUNK_FUTURE;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getTickingChunkFuture() {
-      return this.tickingChunkFuture;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getEntityTickingChunkFuture() {
-      return this.entityTickingChunkFuture;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getFullChunkFuture() {
-      return this.fullChunkFuture;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    @Nullable
-   public LevelChunk getTickingChunk() {
-      CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getTickingChunkFuture();
-      Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = completablefuture.getNow((Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>)null);
-      return either == null ? null : either.left().orElse((LevelChunk)null);
+   public final LevelChunk getTickingChunk() {  // Paper - final for inline
+      // Paper start - rewrite chunk system
+      if (!this.isTickingReady()) {
+         return null;
+      }
+      return (LevelChunk)this.getAvailableChunkNow();
+      // Paper end - rewrite chunk system
    }
 
    public CompletableFuture<?> getChunkSendSyncFuture() {
-      return this.sendSync;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    @Nullable
    public LevelChunk getChunkToSend() {
-      return !this.sendSync.isDone() ? null : this.getTickingChunk();
+      return this.getSendingChunk(); // Paper - rewrite chunk system
    }
 
    @Nullable
-   public LevelChunk getFullChunk() {
-      CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFullChunkFuture();
-      Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = completablefuture.getNow((Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>)null);
-      return either == null ? null : either.left().orElse((LevelChunk)null);
+   public final LevelChunk getFullChunk() {
+      // Paper start - rewrite chunk system
+      if (!this.isFullChunkReady()) {
+         return null;
+      }
+      return (LevelChunk)this.getAvailableChunkNow();
+      // Paper end - rewrite chunk system
    }
 
    @Nullable
    public ChunkStatus getLastAvailableStatus() {
-      for(int i = CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-         ChunkStatus chunkstatus = CHUNK_STATUSES.get(i);
-         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
-         if (completablefuture.getNow(UNLOADED_CHUNK).left().isPresent()) {
-            return chunkstatus;
-         }
-      }
+      return this.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
+   }
 
-      return null;
+   // Paper start
+   public ChunkStatus getChunkHolderStatus() {
+      return this.newChunkHolder.getCurrentGenStatus(); // Paper - rewrite chunk system
    }
+   // Paper end
 
    @Nullable
    public ChunkAccess getLastAvailable() {
-      for(int i = CHUNK_STATUSES.size() - 1; i >= 0; --i) {
-         ChunkStatus chunkstatus = CHUNK_STATUSES.get(i);
-         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
-         if (!completablefuture.isCompletedExceptionally()) {
-            Optional<ChunkAccess> optional = completablefuture.getNow(UNLOADED_CHUNK).left();
-            if (optional.isPresent()) {
-               return optional.get();
-            }
-         }
-      }
-
-      return null;
-   }
-
-   public CompletableFuture<ChunkAccess> getChunkToSave() {
-      return this.chunkToSave;
+      return this.newChunkHolder.getCurrentChunk(); // Paper - rewrite chunk system
    }
 
    public void blockChanged(BlockPos p_140057_) {
-      LevelChunk levelchunk = this.getTickingChunk();
+      // Paper start - replace player chunk loader
+      if (this.playersSentChunkTo.size() == 0) {
+         return;
+      }
+      // Paper end - replace player chunk loader
+      LevelChunk levelchunk = this.getSendingChunk(); // Paper - no-tick view distance
       if (levelchunk != null) {
          int i = this.levelHeightAccessor.getSectionIndex(p_140057_.getY());
          if (this.changedBlocksPerSection[i] == null) {
-            this.hasChangedSections = true;
+            this.hasChangedSections = true; this.addToBroadcastMap(); // Paper - optimise chunk tick iteration
             this.changedBlocksPerSection[i] = new ShortOpenHashSet();
          }
 
@@ -170,16 +_,19 @@
    }
 
    public void sectionLightChanged(LightLayer p_140037_, int p_140038_) {
-      Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = this.getFutureIfPresent(ChunkStatus.INITIALIZE_LIGHT).getNow((Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>)null);
-      if (either != null) {
-         ChunkAccess chunkaccess = either.left().orElse((ChunkAccess)null);
+      // Paper start - no-tick view distance
+      if (true) {
+         ChunkAccess chunkaccess = this.getAvailableChunkNow();
          if (chunkaccess != null) {
             chunkaccess.setUnsaved(true);
-            LevelChunk levelchunk = this.getTickingChunk();
-            if (levelchunk != null) {
+            LevelChunk levelchunk = this.getSendingChunk();
+            // Paper end - no-tick view distance
+
+            if (this.playersSentChunkTo.size() != 0 && levelchunk != null) { // Paper - replace player chunk loader
                int i = this.lightEngine.getMinLightSection();
                int j = this.lightEngine.getMaxLightSection();
                if (p_140038_ >= i && p_140038_ <= j) {
+                  this.addToBroadcastMap(); // Paper - optimise chunk tick iteration
                   int k = p_140038_ - i;
                   if (p_140037_ == LightLayer.SKY) {
                      this.skyChangedLightSectionFilter.set(k);
@@ -194,10 +_,10 @@
    }
 
    public void broadcastChanges(LevelChunk p_140055_) {
-      if (this.hasChangedSections || !this.skyChangedLightSectionFilter.isEmpty() || !this.blockChangedLightSectionFilter.isEmpty()) {
+      if (this.needsBroadcastChanges()) { // Paper - moved into above, other logic needs to call
          Level level = p_140055_.getLevel();
          if (!this.skyChangedLightSectionFilter.isEmpty() || !this.blockChangedLightSectionFilter.isEmpty()) {
-            List<ServerPlayer> list = this.playerProvider.getPlayers(this.pos, true);
+            List<ServerPlayer> list = this.getPlayers(true); // Paper - rewrite chunk system
             if (!list.isEmpty()) {
                ClientboundLightUpdatePacket clientboundlightupdatepacket = new ClientboundLightUpdatePacket(p_140055_.getPos(), this.lightEngine, this.skyChangedLightSectionFilter, this.blockChangedLightSectionFilter);
                this.broadcast(list, clientboundlightupdatepacket);
@@ -208,7 +_,7 @@
          }
 
          if (this.hasChangedSections) {
-            List<ServerPlayer> list1 = this.playerProvider.getPlayers(this.pos, false);
+            List<ServerPlayer> list1 = this.getPlayers(false); // Paper - rewrite chunk system
 
             for(int j = 0; j < this.changedBlocksPerSection.length; ++j) {
                ShortSet shortset = this.changedBlocksPerSection[j];
@@ -257,219 +_,55 @@
 
    }
 
-   private void broadcast(List<ServerPlayer> p_288998_, Packet<?> p_289013_) {
-      p_288998_.forEach((p_296560_) -> {
-         p_296560_.connection.send(p_289013_);
-      });
-   }
-
-   public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getOrScheduleFuture(ChunkStatus p_140050_, ChunkMap p_140051_) {
-      int i = p_140050_.getIndex();
-      CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.futures.get(i);
-      if (completablefuture != null) {
-         Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = completablefuture.getNow(NOT_DONE_YET);
-         if (either == null) {
-            String s = "value in future for status: " + p_140050_ + " was incorrectly set to null at chunk: " + this.pos;
-            throw p_140051_.debugFuturesAndCreateReportedException(new IllegalStateException("null value previously set for chunk status"), s);
-         }
-
-         if (either == NOT_DONE_YET || either.right().isEmpty()) {
-            return completablefuture;
-         }
-      }
-
-      if (ChunkLevel.generationStatus(this.ticketLevel).isOrAfter(p_140050_)) {
-         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = p_140051_.schedule(this, p_140050_);
-         this.updateChunkToSave(completablefuture1, "schedule " + p_140050_);
-         this.futures.set(i, completablefuture1);
-         return completablefuture1;
-      } else {
-         return completablefuture == null ? UNLOADED_CHUNK_FUTURE : completablefuture;
-      }
-   }
-
-   protected void addSaveDependency(String p_200417_, CompletableFuture<?> p_200418_) {
-      if (this.chunkToSaveHistory != null) {
-         this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), p_200418_, p_200417_));
-      }
-
-      this.chunkToSave = this.chunkToSave.thenCombine(p_200418_, (p_200414_, p_200415_) -> {
-         return p_200414_;
-      });
-   }
-
-   private void updateChunkToSave(CompletableFuture<? extends Either<? extends ChunkAccess, ChunkHolder.ChunkLoadingFailure>> p_143018_, String p_143019_) {
-      if (this.chunkToSaveHistory != null) {
-         this.chunkToSaveHistory.push(new ChunkHolder.ChunkSaveDebug(Thread.currentThread(), p_143018_, p_143019_));
-      }
-
-      this.chunkToSave = this.chunkToSave.thenCombine(p_143018_, (p_200411_, p_200412_) -> {
-         return p_200412_.map((p_200406_) -> {
-            return p_200406_;
-         }, (p_200409_) -> {
-            return p_200411_;
-         });
-      });
-   }
-
-   public void addSendDependency(CompletableFuture<?> p_300440_) {
-      if (this.sendSync.isDone()) {
-         this.sendSync = p_300440_;
-      } else {
-         this.sendSync = this.sendSync.thenCombine(p_300440_, (p_296561_, p_296562_) -> {
-            return null;
-         });
-      }
-
-   }
+   // Paper start - rewrite chunk system
+   public List<ServerPlayer> getPlayers(boolean onlyOnWatchDistanceEdge){
+      List<ServerPlayer> ret = new java.util.ArrayList<>();
+      for (int i = 0, len = this.playersSentChunkTo.size(); i < len; ++i) {
+         ServerPlayer player = this.playersSentChunkTo.getUnchecked(i);
+         if (onlyOnWatchDistanceEdge && !this.chunkMap.level.playerChunkLoader.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            continue;
+         }
+         ret.add(player);
+      }
+
+      return ret;
+   }
+
+   public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+      this.broadcast(this.getPlayers(onlyOnWatchDistanceEdge), packet);
+   }
+
+   private void broadcast(List<ServerPlayer> players, Packet<?> packet) {
+      players.forEach((entityplayer) -> {
+         entityplayer.connection.send(packet);
+      });
+   }
+   // Paper end - rewrite chunk system
+
+   // Paper end - rewrite chunk system
+
+   // Paper end - rewrite chunk system
 
    public FullChunkStatus getFullStatus() {
-      return ChunkLevel.fullStatus(this.ticketLevel);
+      return this.newChunkHolder.getChunkStatus(); // Paper - rewrite chunk system) {
    }
 
    public ChunkPos getPos() {
       return this.pos;
    }
 
-   public int getTicketLevel() {
-      return this.ticketLevel;
-   }
-
-   public int getQueueLevel() {
-      return this.queueLevel;
-   }
-
-   private void setQueueLevel(int p_140087_) {
-      this.queueLevel = p_140087_;
-   }
-
-   public void setTicketLevel(int p_140028_) {
-      this.ticketLevel = p_140028_;
-   }
-
-   private void scheduleFullChunkPromotion(ChunkMap p_142999_, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> p_143000_, Executor p_143001_, FullChunkStatus p_287621_) {
-      this.pendingFullStateConfirmation.cancel(false);
-      CompletableFuture<Void> completablefuture = new CompletableFuture<>();
-      completablefuture.thenRunAsync(() -> {
-         p_142999_.onFullChunkStatusChange(this.pos, p_287621_);
-      }, p_143001_);
-      this.pendingFullStateConfirmation = completablefuture;
-      p_143000_.thenAccept((p_200421_) -> {
-         p_200421_.ifLeft((p_200424_) -> {
-            completablefuture.complete((Void)null);
-         });
-      });
-   }
-
-   private void demoteFullChunk(ChunkMap p_287599_, FullChunkStatus p_287649_) {
-      this.pendingFullStateConfirmation.cancel(false);
-      p_287599_.onFullChunkStatusChange(this.pos, p_287649_);
-   }
-
-   protected void updateFutures(ChunkMap p_143004_, Executor p_143005_) {
-      ChunkStatus chunkstatus = ChunkLevel.generationStatus(this.oldTicketLevel);
-      ChunkStatus chunkstatus1 = ChunkLevel.generationStatus(this.ticketLevel);
-      boolean flag = ChunkLevel.isLoaded(this.oldTicketLevel);
-      boolean flag1 = ChunkLevel.isLoaded(this.ticketLevel);
-      FullChunkStatus fullchunkstatus = ChunkLevel.fullStatus(this.oldTicketLevel);
-      FullChunkStatus fullchunkstatus1 = ChunkLevel.fullStatus(this.ticketLevel);
-      if (flag) {
-         Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.right(new ChunkHolder.ChunkLoadingFailure() {
-            public String toString() {
-               return "Unloaded ticket level " + ChunkHolder.this.pos;
-            }
-         });
-
-         for(int i = flag1 ? chunkstatus1.getIndex() + 1 : 0; i <= chunkstatus.getIndex(); ++i) {
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.futures.get(i);
-            if (completablefuture == null) {
-               this.futures.set(i, CompletableFuture.completedFuture(either));
-            }
-         }
-      }
-
-      boolean flag5 = fullchunkstatus.isOrAfter(FullChunkStatus.FULL);
-      boolean flag6 = fullchunkstatus1.isOrAfter(FullChunkStatus.FULL);
-      this.wasAccessibleSinceLastSave |= flag6;
-      if (!flag5 && flag6) {
-         this.fullChunkFuture = p_143004_.prepareAccessibleChunk(this);
-         this.scheduleFullChunkPromotion(p_143004_, this.fullChunkFuture, p_143005_, FullChunkStatus.FULL);
-         this.updateChunkToSave(this.fullChunkFuture, "full");
-      }
-
-      if (flag5 && !flag6) {
-         this.fullChunkFuture.complete(UNLOADED_LEVEL_CHUNK);
-         this.fullChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-      }
-
-      boolean flag7 = fullchunkstatus.isOrAfter(FullChunkStatus.BLOCK_TICKING);
-      boolean flag2 = fullchunkstatus1.isOrAfter(FullChunkStatus.BLOCK_TICKING);
-      if (!flag7 && flag2) {
-         this.tickingChunkFuture = p_143004_.prepareTickingChunk(this);
-         this.scheduleFullChunkPromotion(p_143004_, this.tickingChunkFuture, p_143005_, FullChunkStatus.BLOCK_TICKING);
-         this.updateChunkToSave(this.tickingChunkFuture, "ticking");
-      }
-
-      if (flag7 && !flag2) {
-         this.tickingChunkFuture.complete(UNLOADED_LEVEL_CHUNK);
-         this.tickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-      }
-
-      boolean flag3 = fullchunkstatus.isOrAfter(FullChunkStatus.ENTITY_TICKING);
-      boolean flag4 = fullchunkstatus1.isOrAfter(FullChunkStatus.ENTITY_TICKING);
-      if (!flag3 && flag4) {
-         if (this.entityTickingChunkFuture != UNLOADED_LEVEL_CHUNK_FUTURE) {
-            throw (IllegalStateException)Util.pauseInIde(new IllegalStateException());
-         }
-
-         this.entityTickingChunkFuture = p_143004_.prepareEntityTickingChunk(this);
-         this.scheduleFullChunkPromotion(p_143004_, this.entityTickingChunkFuture, p_143005_, FullChunkStatus.ENTITY_TICKING);
-         this.updateChunkToSave(this.entityTickingChunkFuture, "entity ticking");
-      }
-
-      if (flag3 && !flag4) {
-         this.entityTickingChunkFuture.complete(UNLOADED_LEVEL_CHUNK);
-         this.entityTickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
-      }
-
-      if (!fullchunkstatus1.isOrAfter(fullchunkstatus)) {
-         this.demoteFullChunk(p_143004_, fullchunkstatus1);
-      }
-
-      this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
-      this.oldTicketLevel = this.ticketLevel;
-   }
-
-   public boolean wasAccessibleSinceLastSave() {
-      return this.wasAccessibleSinceLastSave;
-   }
-
-   public void refreshAccessibility() {
-      this.wasAccessibleSinceLastSave = ChunkLevel.fullStatus(this.ticketLevel).isOrAfter(FullChunkStatus.FULL);
-   }
+   public final int getTicketLevel() {
+      return this.newChunkHolder.getTicketLevel(); // Paper - rewrite chunk system
+   }
+
+   // Paper - rewrite chunk system
 
    public void replaceProtoChunk(ImposterProtoChunk p_140053_) {
-      for(int i = 0; i < this.futures.length(); ++i) {
-         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.futures.get(i);
-         if (completablefuture != null) {
-            Optional<ChunkAccess> optional = completablefuture.getNow(UNLOADED_CHUNK).left();
-            if (!optional.isEmpty() && optional.get() instanceof ProtoChunk) {
-               this.futures.set(i, CompletableFuture.completedFuture(Either.left(p_140053_)));
-            }
-         }
-      }
-
-      this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(p_140053_.getWrapped())), "replaceProto");
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    public List<Pair<ChunkStatus, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>>> getAllFutures() {
-      List<Pair<ChunkStatus, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>>> list = new ArrayList<>();
-
-      for(int i = 0; i < CHUNK_STATUSES.size(); ++i) {
-         list.add(Pair.of(CHUNK_STATUSES.get(i), this.futures.get(i)));
-      }
-
-      return list;
+      throw new UnsupportedOperationException(); // Paper - rewrite chunk system
    }
 
    public interface ChunkLoadingFailure {
@@ -500,4 +_,18 @@
    public interface PlayerProvider {
       List<ServerPlayer> getPlayers(ChunkPos p_183717_, boolean p_183718_);
    }
+
+   // Paper start
+   public final boolean isEntityTickingReady() {
+      return this.newChunkHolder.isEntityTickingReady(); // Paper - rewrite chunk system
+   }
+
+   public final boolean isTickingReady() {
+      return this.newChunkHolder.isTickingReady(); // Paper - rewrite chunk system
+   }
+
+   public final boolean isFullChunkReady() {
+      return this.newChunkHolder.isFullChunkReady(); // Paper - rewrite chunk system
+   }
+   // Paper end
 }
