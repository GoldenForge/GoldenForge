--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -1,21 +_,21 @@
 package net.minecraft.server.level;
 
+import com.destroystokyo.paper.util.MCUtil;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Optional;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -50,9 +_,9 @@
    private static final List<ChunkStatus> f_8326_ = ChunkStatus.m_62349_();
    private final DistanceManager f_8327_;
    public final ServerLevel f_8329_;
-   final Thread f_8330_;
+   public final Thread f_8330_;
    final ThreadedLevelLightEngine f_8331_;
-   private final ServerChunkCache.MainThreadExecutor f_8332_;
+   public final ServerChunkCache.MainThreadExecutor f_8332_;
    public final ChunkMap f_8325_;
    private final DimensionDataStorage f_8333_;
    private long f_8334_;
@@ -80,6 +_,233 @@
       this.m_8488_();
    }
 
+   final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
+   final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+
+   private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
+
+   private static int getChunkCacheKey(int x, int z) {
+      return x & 3 | ((z & 3) << 2);
+   }
+
+   public void addLoadedChunk(LevelChunk chunk) {
+      this.loadedChunkMapSeqLock.acquireWrite();
+      try {
+         this.loadedChunkMap.put(chunk.coordinateKey, chunk);
+      } finally {
+         this.loadedChunkMapSeqLock.releaseWrite();
+      }
+
+      // rewrite cache if we have to
+      // we do this since we also cache null chunks
+      int cacheKey = getChunkCacheKey(chunk.locX, chunk.locZ);
+
+      this.lastLoadedChunks[cacheKey] = chunk;
+   }
+
+   public void removeLoadedChunk(LevelChunk chunk) {
+      this.loadedChunkMapSeqLock.acquireWrite();
+      try {
+         this.loadedChunkMap.remove(chunk.coordinateKey);
+      } finally {
+         this.loadedChunkMapSeqLock.releaseWrite();
+      }
+
+      // rewrite cache if we have to
+      // we do this since we also cache null chunks
+      int cacheKey = getChunkCacheKey(chunk.locX, chunk.locZ);
+
+      LevelChunk cachedChunk = this.lastLoadedChunks[cacheKey];
+      if (cachedChunk != null && cachedChunk.coordinateKey == chunk.coordinateKey) {
+         this.lastLoadedChunks[cacheKey] = null;
+      }
+   }
+
+   public final LevelChunk getChunkAtIfLoadedMainThread(int x, int z) {
+      int cacheKey = getChunkCacheKey(x, z);
+
+      LevelChunk cachedChunk = this.lastLoadedChunks[cacheKey];
+      if (cachedChunk != null && cachedChunk.locX == x & cachedChunk.locZ == z) {
+         return this.lastLoadedChunks[cacheKey];
+      }
+
+      long chunkKey = ChunkPos.m_45589_(x, z);
+
+      cachedChunk = this.loadedChunkMap.get(chunkKey);
+      // Skipping a null check to avoid extra instructions to improve inline capability
+      this.lastLoadedChunks[cacheKey] = cachedChunk;
+      return cachedChunk;
+   }
+
+   public final LevelChunk getChunkAtIfLoadedMainThreadNoCache(int x, int z) {
+      return this.loadedChunkMap.get(ChunkPos.m_45589_(x, z));
+   }
+
+   @Nullable
+   public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
+      long k = ChunkPos.m_45589_(x, z);
+
+      if (Thread.currentThread() == this.f_8330_) {
+         return this.getChunkAtIfLoadedMainThread(x, z);
+      }
+
+      LevelChunk ret = null;
+      long readlock;
+      do {
+         readlock = this.loadedChunkMapSeqLock.acquireRead();
+         try {
+            ret = this.loadedChunkMap.get(k);
+         } catch (Throwable thr) {
+            if (thr instanceof ThreadDeath) {
+               throw (ThreadDeath)thr;
+            }
+            // re-try, this means a CME occurred...
+            continue;
+         }
+      } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
+
+      return ret;
+   }
+
+   public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
+      if (Thread.currentThread() != this.f_8330_) {
+         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = new CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>();
+         this.f_8332_.execute(() -> {
+            this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
+               if (ex != null) {
+                  future.completeExceptionally(ex);
+               } else {
+                  future.complete(chunk);
+               }
+            });
+         });
+         return future;
+      }
+
+      long k = ChunkPos.m_45589_(x, z);
+      ChunkPos chunkPos = new ChunkPos(x, z);
+
+      ChunkAccess ichunkaccess;
+
+      // try cache
+      for (int l = 0; l < 4; ++l) {
+         if (k == this.f_8337_[l] && ChunkStatus.f_62326_ == this.f_8338_[l]) {
+            ichunkaccess = this.f_8339_[l];
+            if (ichunkaccess != null) { // CraftBukkit - the chunk can become accessible in the meantime TODO for non-null chunks it might also make sense to check that the chunk's state hasn't changed in the meantime
+
+               // move to first in cache
+
+               for (int i1 = 3; i1 > 0; --i1) {
+                  this.f_8337_[i1] = this.f_8337_[i1 - 1];
+                  this.f_8338_[i1] = this.f_8338_[i1 - 1];
+                  this.f_8339_[i1] = this.f_8339_[i1 - 1];
+               }
+
+               this.f_8337_[0] = k;
+               this.f_8338_[0] = ChunkStatus.f_62326_;
+               this.f_8339_[0] = ichunkaccess;
+
+               return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+            }
+         }
+      }
+
+      if (gen) {
+         return this.bringToFullStatusAsync(x, z, chunkPos, isUrgent);
+      }
+
+      ChunkAccess current = this.getChunkAtImmediately(x, z); // we want to bypass ticket restrictions
+      if (current != null) {
+         if (!(current instanceof net.minecraft.world.level.chunk.ImposterProtoChunk) && !(current instanceof LevelChunk)) {
+            return CompletableFuture.completedFuture(ChunkHolder.f_139995_);
+         }
+         // we know the chunk is at full status here (either in read-only mode or the real thing)
+         return this.bringToFullStatusAsync(x, z, chunkPos, isUrgent);
+      }
+
+      // here we don't know what status it is and we're not supposed to generate
+      // so we asynchronously load empty status
+      return this.bringToStatusAsync(x, z, chunkPos, ChunkStatus.f_62314_, isUrgent).thenCompose((either) -> {
+         ChunkAccess chunk = either.left().orElse(null);
+         if (!(chunk instanceof net.minecraft.world.level.chunk.ImposterProtoChunk) && !(chunk instanceof LevelChunk)) {
+            // the chunk on disk was not a full status chunk
+            return CompletableFuture.completedFuture(ChunkHolder.f_139995_);
+         }
+         // bring to full status if required
+         return this.bringToFullStatusAsync(x, z, chunkPos, isUrgent);
+      });
+   }
+
+
+   // Paper start
+   @Nullable
+   public ChunkAccess getChunkAtImmediately(int x, int z) {
+      ChunkHolder holder = this.f_8325_.m_140327_(ChunkPos.m_45589_(x, z));
+      if (holder == null) {
+         return null;
+      }
+
+      return holder.m_140089_();
+   }
+
+   private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> bringToFullStatusAsync(int x, int z, ChunkPos chunkPos, boolean isUrgent) {
+      return this.bringToStatusAsync(x, z, chunkPos, ChunkStatus.f_62326_, isUrgent);
+   }
+   private long asyncLoadSeqCounter;
+
+   private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> bringToStatusAsync(int x, int z, ChunkPos chunkPos, ChunkStatus status, boolean isUrgent) {
+      CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = this.getChunkFutureMainThread(x, z, status, true, isUrgent);
+      Long identifier = Long.valueOf(this.asyncLoadSeqCounter++);
+      int ticketLevel = MCUtil.getTicketLevelFor(status);
+      this.addTicketAtLevel(TicketType.ASYNC_LOAD, chunkPos, ticketLevel, identifier);
+
+      return future.thenComposeAsync((Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either) -> {
+         // either left -> success
+         // either right -> failure
+
+         this.removeTicketAtLevel(TicketType.ASYNC_LOAD, chunkPos, ticketLevel, identifier);
+         this.addTicketAtLevel(TicketType.f_9449_, chunkPos, ticketLevel, chunkPos); // allow unloading
+
+         Optional<ChunkHolder.ChunkLoadingFailure> failure = either.right();
+
+         if (failure.isPresent()) {
+            // failure
+            throw new IllegalStateException("Chunk failed to load: " + failure.get().toString());
+         }
+
+         return CompletableFuture.completedFuture(either);
+      }, this.f_8332_);
+   }
+
+   public <T> void addTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkPos, int ticketLevel, T identifier) {
+      this.f_8327_.m_140792_(ticketType, chunkPos, ticketLevel, identifier);
+   }
+
+   public <T> void removeTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkPos, int ticketLevel, T identifier) {
+      this.f_8327_.m_140823_(ticketType, chunkPos, ticketLevel, identifier);
+   }
+
+   public boolean markUrgent(ChunkPos coords) {
+      return this.f_8327_.markUrgent(coords);
+   }
+
+   public boolean markHighPriority(ChunkPos coords, int priority) {
+      return this.f_8327_.markHighPriority(coords, priority);
+   }
+
+   public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+      this.f_8327_.markAreaHighPriority(center, priority, radius);
+   }
+
+   public void clearAreaPriorityTickets(ChunkPos center, int radius) {
+      this.f_8327_.clearAreaPriorityTickets(center, radius);
+   }
+
+   public void clearPriorityTickets(ChunkPos coords) {
+      this.f_8327_.clearPriorityTickets(coords);
+   }
+   // Paper end - async chunk io
+
    public ThreadedLevelLightEngine m_7827_() {
       return this.f_8331_;
    }
@@ -107,11 +_,18 @@
 
    @Nullable
    public ChunkAccess m_7587_(int p_8360_, int p_8361_, ChunkStatus p_8362_, boolean p_8363_) {
+      final int x1 = p_8360_; final int z1 = p_8361_; // Paper - conflict on variable change
       if (Thread.currentThread() != this.f_8330_) {
          return CompletableFuture.supplyAsync(() -> {
             return this.m_7587_(p_8360_, p_8361_, p_8362_, p_8363_);
          }, this.f_8332_).join();
       } else {
+         // Paper start - optimise for loaded chunks
+         LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(p_8360_, p_8361_);
+         if (ifLoaded != null) {
+            return ifLoaded;
+         }
+         // Paper end
          ProfilerFiller profilerfiller = this.f_8329_.m_46473_();
          profilerfiller.m_6174_("getChunk");
          long i = ChunkPos.m_45589_(p_8360_, p_8361_);
@@ -126,8 +_,21 @@
          }
 
          profilerfiller.m_6174_("getChunkCacheMiss");
-         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.m_8456_(p_8360_, p_8361_, p_8362_, p_8363_);
-         this.f_8332_.m_18701_(completablefuture::isDone);
+         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFutureMainThread(p_8360_, p_8361_, p_8362_, p_8363_, true);
+         ServerChunkCache.MainThreadExecutor chunkproviderserver_b = this.f_8332_;
+         if (!completablefuture.isDone()) { // Paper
+            // Paper start - async chunk io/loading
+            ChunkPos pair = new ChunkPos(x1, z1); // Paper - Chunk priority
+            this.f_8327_.markUrgent(pair); // Paper - Chunk priority
+            this.f_8329_.asyncChunkTaskManager.raisePriority(x1, z1, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
+            com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.f_8329_, x1, z1);
+            // Paper end
+            com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.f_8329_, x1, z1); // Paper - sync load info
+            chunkproviderserver_b.m_18701_(completablefuture::isDone);
+            com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
+            this.f_8327_.clearPriorityTickets(pair); // Paper - Chunk priority
+            this.f_8327_.clearUrgent(pair); // Paper - Chunk priority
+         } // Paper
          ChunkAccess chunkaccess1 = completablefuture.join().map((p_8406_) -> {
             return p_8406_;
          }, (p_8423_) -> {
@@ -161,6 +_,7 @@
          if (chunkholder == null) {
             return null;
          } else {
+            if (chunkholder.currentlyLoading != null) return chunkholder.currentlyLoading; // Forge: If the requested chunk is loading, bypass the future chain to prevent a deadlock.
             Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = chunkholder.m_140080_(ChunkStatus.f_62326_).getNow((Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>)null);
             if (either == null) {
                return null;
@@ -203,15 +_,20 @@
    }
 
    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> m_8456_(int p_8457_, int p_8458_, ChunkStatus p_8459_, boolean p_8460_) {
+      return getChunkFutureMainThread(p_8457_, p_8458_, p_8459_, p_8460_, false);
+   }
+   private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int p_8457_, int p_8458_, ChunkStatus p_8459_, boolean p_8460_, boolean isUrgent) {
       ChunkPos chunkpos = new ChunkPos(p_8457_, p_8458_);
       long i = chunkpos.m_45588_();
       int j = 33 + ChunkStatus.m_62370_(p_8459_);
       ChunkHolder chunkholder = this.m_8364_(i);
       if (p_8460_) {
          this.f_8327_.m_140792_(TicketType.f_9449_, chunkpos, j, chunkpos);
+         if (isUrgent) this.f_8327_.markUrgent(chunkpos); // Paper - Chunk priority
          if (this.m_8416_(chunkholder, j)) {
             ProfilerFiller profilerfiller = this.f_8329_.m_46473_();
             profilerfiller.m_6180_("chunkLoad");
+            f_8327_.delayDistanceManagerTick = false; // Paper - Chunk priority - ensure this is never false
             this.m_8489_();
             chunkholder = this.m_8364_(i);
             profilerfiller.m_7238_();
@@ -221,7 +_,15 @@
          }
       }
 
-      return this.m_8416_(chunkholder, j) ? ChunkHolder.f_139996_ : chunkholder.m_140049_(p_8459_, this.f_8325_);
+      CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future =  this.m_8416_(chunkholder, j) ? ChunkHolder.f_139996_ : chunkholder.m_140049_(p_8459_, this.f_8325_);
+
+      // Paper end - prevent plugin unloads from removing our ticket
+      if (isUrgent) {
+         future.thenAccept(either -> this.f_8327_.clearUrgent(chunkpos));
+      }
+      return future;
+      // Paper end
+
    }
 
    private boolean m_8416_(@Nullable ChunkHolder p_8417_, int p_8418_) {
@@ -267,6 +_,7 @@
    }
 
    boolean m_8489_() {
+      if (f_8327_.delayDistanceManagerTick) return false; // Paper - Chunk priority
       boolean flag = this.f_8327_.m_140805_(this.f_8325_);
       boolean flag1 = this.f_8325_.m_140324_();
       if (!flag && !flag1) {
@@ -278,15 +_,10 @@
    }
 
    public boolean m_143239_(long p_143240_) {
-      ChunkHolder chunkholder = this.m_8364_(p_143240_);
-      if (chunkholder == null) {
-         return false;
-      } else if (!this.f_8329_.m_183438_(p_143240_)) {
-         return false;
-      } else {
-         Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = chunkholder.m_140026_().getNow((Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>)null);
-         return either != null && either.left().isPresent();
-      }
+      // Paper start - replace player chunk loader system
+      ChunkHolder holder = this.f_8325_.m_140327_(p_143240_);
+      return holder != null && holder.isTickingReady();
+      // Paper end - replace player chunk loader system
    }
 
    public void m_8419_(boolean p_8420_) {
@@ -294,6 +_,13 @@
       this.f_8325_.m_140318_(p_8420_);
    }
 
+   // Paper start - duplicate save, but call incremental
+   public void saveIncrementally() {
+      this.m_8489_();
+      this.f_8325_.saveIncrementally();
+   }
+   // Paper end
+
    public void close() throws IOException {
       this.m_8419_(true);
       this.f_8331_.close();
@@ -306,6 +_,7 @@
       this.m_8489_();
       this.f_8329_.m_46473_().m_6182_("chunks");
       if (p_201914_) {
+         this.f_8325_.playerChunkManager.tick(); // Paper - this is mostly is to account for view distance changes
          this.m_8490_();
       }
 
@@ -315,6 +_,8 @@
       this.m_8488_();
    }
 
+   final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+
    private void m_8490_() {
       long i = this.f_8329_.m_46467_();
       long j = i - this.f_8334_;
@@ -333,33 +_,61 @@
          NaturalSpawner.SpawnState naturalspawner$spawnstate = NaturalSpawner.m_186524_(l, this.f_8329_.m_8583_(), this::m_8370_, new LocalMobCapCalculator(this.f_8325_));
          this.f_8340_ = naturalspawner$spawnstate;
          profilerfiller.m_6182_("filteringLoadedChunks");
-         List<ServerChunkCache.ChunkAndHolder> list = Lists.newArrayListWithCapacity(l);
-
-         for(ChunkHolder chunkholder : this.f_8325_.m_140416_()) {
-            LevelChunk levelchunk = chunkholder.m_140085_();
-            if (levelchunk != null) {
-               list.add(new ServerChunkCache.ChunkAndHolder(levelchunk, chunkholder));
-            }
-         }
+//         List<ServerChunkCache.ChunkAndHolder> list = Lists.newArrayListWithCapacity(l);
+//
+//         for(ChunkHolder chunkholder : this.chunkMap.getChunks()) {
+//            LevelChunk levelchunk = chunkholder.getTickingChunk();
+//            if (levelchunk != null) {
+//               list.add(new ServerChunkCache.ChunkAndHolder(levelchunk, chunkholder));
+//            }
+//         }
 
          profilerfiller.m_6182_("spawnAndTick");
          boolean flag2 = this.f_8329_.m_46469_().m_46207_(GameRules.f_46134_);
-         Collections.shuffle(list);
-
-         for(ServerChunkCache.ChunkAndHolder serverchunkcache$chunkandholder : list) {
-            LevelChunk levelchunk1 = serverchunkcache$chunkandholder.f_184028_;
-            ChunkPos chunkpos = levelchunk1.m_7697_();
-            if (this.f_8329_.m_201916_(chunkpos) && this.f_8325_.m_183879_(chunkpos)) {
-               levelchunk1.m_187632_(j);
-               if (flag2 && (this.f_8335_ || this.f_8336_) && this.f_8329_.m_6857_().m_61927_(chunkpos)) {
-                  NaturalSpawner.m_47029_(this.f_8329_, levelchunk1, naturalspawner$spawnstate, this.f_8336_, this.f_8335_, flag1);
-               }
-
-               if (this.f_8329_.m_183438_(chunkpos.m_45588_())) {
-                  this.f_8329_.m_8714_(levelchunk1, k);
-               }
-            }
-         }
+         //Collections.shuffle(list);
+
+         // Paper start - optimise chunk tick iteration
+         Iterator<LevelChunk> iterator1;
+         if (/*this.level.paperConfig.perPlayerMobSpawns*/ false) {
+            iterator1 = this.entityTickingChunks.iterator();
+         } else {
+            iterator1 = this.entityTickingChunks.unsafeIterator();
+            List<LevelChunk> shuffled = Lists.newArrayListWithCapacity(this.entityTickingChunks.size());
+            while (iterator1.hasNext()) {
+               shuffled.add(iterator1.next());
+            }
+            Collections.shuffle(shuffled);
+            iterator1 = shuffled.iterator();
+         }
+
+         int chunksTicked = 0; // Paper
+         try {
+            while (iterator1.hasNext()) {
+               LevelChunk levelchunk1 = iterator1.next();
+               ChunkHolder holder = levelchunk1.playerChunk;
+               if (holder != null) {
+                  // Paper - move down
+                  ChunkPos chunkpos = levelchunk1.m_7697_();
+                  if ((this.f_8329_.m_201916_(chunkpos) && this.f_8325_.m_183879_(chunkpos)) || this.f_8327_.shouldForceTicks(chunkpos.m_45588_())) {
+                     levelchunk1.m_187632_(j);
+                     if (flag2 && (this.f_8335_ || this.f_8336_) && this.f_8329_.m_6857_().m_61927_(chunkpos)) {
+                        NaturalSpawner.m_47029_(this.f_8329_, levelchunk1, naturalspawner$spawnstate, this.f_8336_, this.f_8335_, flag1);
+                     }
+
+                     if (this.f_8329_.m_183438_(chunkpos.m_45588_())) {
+                        this.f_8329_.m_8714_(levelchunk1, k);
+                        if ((chunksTicked++ & 1) == 0)
+                           net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
+                     }
+                  }
+               }
+            }
+         } finally {
+            if (iterator1 instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator safeIterator) {
+               safeIterator.finishedIterating();
+            }
+         }
+         // Paper end - optimise chunk tick iteration
 
          profilerfiller.m_6182_("customSpawners");
          if (flag2) {
@@ -367,12 +_,37 @@
          }
 
          profilerfiller.m_6182_("broadcast");
-         list.forEach((p_184022_) -> {
-            p_184022_.f_184029_.m_140054_(p_184022_.f_184028_);
-         });
-         profilerfiller.m_7238_();
-         profilerfiller.m_7238_();
+         if (!this.f_8325_.needsChangeBroadcasting.isEmpty()) {
+            ReferenceOpenHashSet<ChunkHolder> copy = this.f_8325_.needsChangeBroadcasting.clone();
+            this.f_8325_.needsChangeBroadcasting.clear();
+            for (ChunkHolder holder : copy) {
+               holder.m_140054_(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
+               if (holder.needsBroadcastChanges()) {
+                  // I DON'T want to KNOW what DUMB plugins might be doing.
+                  this.f_8325_.needsChangeBroadcasting.add(holder);
+               }
+            }
+         }
+         profilerfiller.m_7238_();
+         profilerfiller.m_7238_();
+         // Paper start - controlled flush for entity tracker packets
+         List<net.minecraft.network.Connection> disabledFlushes = new java.util.ArrayList<>(this.f_8329_.f_8546_.size());
+         for (ServerPlayer player : this.f_8329_.f_8546_) {
+            net.minecraft.server.network.ServerGamePacketListenerImpl connection = player.f_8906_;
+            if (connection != null) {
+               connection.f_9742_.disableAutomaticFlush();
+               disabledFlushes.add(connection.f_9742_);
+            }
+         }
+         try { // Paper end - controlled flush for entity tracker packets
          this.f_8325_.m_140421_();
+            // Paper start - controlled flush for entity tracker packets
+         } finally {
+            for (net.minecraft.network.Connection networkManager : disabledFlushes) {
+               networkManager.enableAutomaticFlush();
+            }
+         }
+         // Paper end - controlled flush for entity tracker packets
       }
    }
 
@@ -426,11 +_,17 @@
    }
 
    public <T> void m_8387_(TicketType<T> p_8388_, ChunkPos p_8389_, int p_8390_, T p_8391_) {
-      this.f_8327_.m_140840_(p_8388_, p_8389_, p_8390_, p_8391_);
+      addRegionTicket(p_8388_, p_8389_, p_8390_, p_8391_, false);
+   }
+   public <T> void addRegionTicket(TicketType<T> p_8388_, ChunkPos p_8389_, int p_8390_, T p_8391_, boolean forceTicks) {
+      this.f_8327_.addRegionTicket(p_8388_, p_8389_, p_8390_, p_8391_, forceTicks);
    }
 
    public <T> void m_8438_(TicketType<T> p_8439_, ChunkPos p_8440_, int p_8441_, T p_8442_) {
-      this.f_8327_.m_140849_(p_8439_, p_8440_, p_8441_, p_8442_);
+      removeRegionTicket(p_8439_, p_8440_, p_8441_, p_8442_, false);
+   }
+   public <T> void removeRegionTicket(TicketType<T> p_8439_, ChunkPos p_8440_, int p_8441_, T p_8442_, boolean forceTicks) {
+      this.f_8327_.removeRegionTicket(p_8439_, p_8440_, p_8441_, p_8442_, forceTicks);
    }
 
    public void m_6692_(ChunkPos p_8400_, boolean p_8401_) {
@@ -502,7 +_,7 @@
    static record ChunkAndHolder(LevelChunk f_184028_, ChunkHolder f_184029_) {
    }
 
-   final class MainThreadExecutor extends BlockableEventLoop<Runnable> {
+   public final class MainThreadExecutor extends BlockableEventLoop<Runnable> {
       MainThreadExecutor(Level p_8494_) {
          super("Chunk source main thread executor for " + p_8494_.m_46472_().m_135782_());
       }
@@ -529,11 +_,17 @@
       }
 
       public boolean m_7245_() {
-         if (ServerChunkCache.this.m_8489_()) {
-            return true;
-         } else {
-            ServerChunkCache.this.f_8331_.m_9409_();
-            return super.m_7245_();
+         try {
+            boolean execChunkTask = com.destroystokyo.paper.io.chunk.ChunkTaskManager.pollChunkWaitQueue() || ServerChunkCache.this.f_8329_.asyncChunkTaskManager.pollNextChunkTask(); // Paper
+            ServerChunkCache.this.f_8325_.playerChunkManager.tickMidTick(); // Paper
+            if (ServerChunkCache.this.m_8489_()) {
+               return true;
+            } else {
+               ServerChunkCache.this.f_8331_.m_9409_();
+               return super.m_7245_() || execChunkTask; // Paper
+            }
+         } finally {
+            f_8325_.callbackExecutor.run();
          }
       }
    }
