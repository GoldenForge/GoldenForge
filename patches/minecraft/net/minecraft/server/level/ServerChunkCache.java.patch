--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -50,9 +_,9 @@
    private static final List<ChunkStatus> f_8326_ = ChunkStatus.m_62349_();
    private final DistanceManager f_8327_;
    public final ServerLevel f_8329_;
-   final Thread f_8330_;
+   public final Thread f_8330_;
    final ThreadedLevelLightEngine f_8331_;
-   private final ServerChunkCache.MainThreadExecutor f_8332_;
+   public final ServerChunkCache.MainThreadExecutor f_8332_;
    public final ChunkMap f_8325_;
    private final DimensionDataStorage f_8333_;
    private long f_8334_;
@@ -80,6 +_,90 @@
       this.m_8488_();
    }
 
+   final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
+   final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+
+   private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
+
+   private static int getChunkCacheKey(int x, int z) {
+      return x & 3 | ((z & 3) << 2);
+   }
+
+   public void addLoadedChunk(LevelChunk chunk) {
+      this.loadedChunkMapSeqLock.acquireWrite();
+      try {
+         this.loadedChunkMap.put(chunk.coordinateKey, chunk);
+      } finally {
+         this.loadedChunkMapSeqLock.releaseWrite();
+      }
+
+      // rewrite cache if we have to
+      // we do this since we also cache null chunks
+      int cacheKey = getChunkCacheKey(chunk.locX, chunk.locZ);
+
+      this.lastLoadedChunks[cacheKey] = chunk;
+   }
+
+   public void removeLoadedChunk(LevelChunk chunk) {
+      this.loadedChunkMapSeqLock.acquireWrite();
+      try {
+         this.loadedChunkMap.remove(chunk.coordinateKey);
+      } finally {
+         this.loadedChunkMapSeqLock.releaseWrite();
+      }
+
+      // rewrite cache if we have to
+      // we do this since we also cache null chunks
+      int cacheKey = getChunkCacheKey(chunk.locX, chunk.locZ);
+
+      LevelChunk cachedChunk = this.lastLoadedChunks[cacheKey];
+      if (cachedChunk != null && cachedChunk.coordinateKey == chunk.coordinateKey) {
+         this.lastLoadedChunks[cacheKey] = null;
+      }
+   }
+
+   public final LevelChunk getChunkAtIfLoadedMainThread(int x, int z) {
+      int cacheKey = getChunkCacheKey(x, z);
+
+      LevelChunk cachedChunk = this.lastLoadedChunks[cacheKey];
+      if (cachedChunk != null && cachedChunk.locX == x & cachedChunk.locZ == z) {
+         return this.lastLoadedChunks[cacheKey];
+      }
+
+      long chunkKey = ChunkPos.m_45589_(x, z);
+
+      cachedChunk = this.loadedChunkMap.get(chunkKey);
+      // Skipping a null check to avoid extra instructions to improve inline capability
+      this.lastLoadedChunks[cacheKey] = cachedChunk;
+      return cachedChunk;
+   }
+
+   @Nullable
+   public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
+      long k = ChunkPos.m_45589_(x, z);
+
+      if (Thread.currentThread() == this.f_8330_) {
+         return this.getChunkAtIfLoadedMainThread(x, z);
+      }
+
+      LevelChunk ret = null;
+      long readlock;
+      do {
+         readlock = this.loadedChunkMapSeqLock.acquireRead();
+         try {
+            ret = this.loadedChunkMap.get(k);
+         } catch (Throwable thr) {
+            if (thr instanceof ThreadDeath) {
+               throw (ThreadDeath)thr;
+            }
+            // re-try, this means a CME occurred...
+            continue;
+         }
+      } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
+
+      return ret;
+   }
+
    public ThreadedLevelLightEngine m_7827_() {
       return this.f_8331_;
    }
@@ -107,11 +_,18 @@
 
    @Nullable
    public ChunkAccess m_7587_(int p_8360_, int p_8361_, ChunkStatus p_8362_, boolean p_8363_) {
+      final int x1 = p_8360_; final int z1 = p_8361_; // Paper - conflict on variable change
       if (Thread.currentThread() != this.f_8330_) {
          return CompletableFuture.supplyAsync(() -> {
             return this.m_7587_(p_8360_, p_8361_, p_8362_, p_8363_);
          }, this.f_8332_).join();
       } else {
+         // Paper start - optimise for loaded chunks
+         LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(p_8360_, p_8361_);
+         if (ifLoaded != null) {
+            return ifLoaded;
+         }
+         // Paper end
          ProfilerFiller profilerfiller = this.f_8329_.m_46473_();
          profilerfiller.m_6174_("getChunk");
          long i = ChunkPos.m_45589_(p_8360_, p_8361_);
@@ -126,8 +_,21 @@
          }
 
          profilerfiller.m_6174_("getChunkCacheMiss");
-         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.m_8456_(p_8360_, p_8361_, p_8362_, p_8363_);
-         this.f_8332_.m_18701_(completablefuture::isDone);
+         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFutureMainThread(p_8360_, p_8361_, p_8362_, p_8363_, true);
+         ServerChunkCache.MainThreadExecutor chunkproviderserver_b = this.f_8332_;
+         if (!completablefuture.isDone()) { // Paper
+            // Paper start - async chunk io/loading
+            ChunkPos pair = new ChunkPos(x1, z1); // Paper - Chunk priority
+            //this.distanceManager.markUrgent(pair); // Paper - Chunk priority
+            this.f_8329_.asyncChunkTaskManager.raisePriority(x1, z1, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
+            com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.f_8329_, x1, z1);
+            // Paper end
+            com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.f_8329_, x1, z1); // Paper - sync load info
+            chunkproviderserver_b.m_18701_(completablefuture::isDone);
+            com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
+            //this.distanceManager.clearPriorityTickets(pair); // Paper - Chunk priority
+            //this.distanceManager.clearUrgent(pair); // Paper - Chunk priority
+         } // Paper
          ChunkAccess chunkaccess1 = completablefuture.join().map((p_8406_) -> {
             return p_8406_;
          }, (p_8423_) -> {
@@ -161,6 +_,7 @@
          if (chunkholder == null) {
             return null;
          } else {
+            if (chunkholder.currentlyLoading != null) return chunkholder.currentlyLoading; // Forge: If the requested chunk is loading, bypass the future chain to prevent a deadlock.
             Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = chunkholder.m_140080_(ChunkStatus.f_62326_).getNow((Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>)null);
             if (either == null) {
                return null;
@@ -203,6 +_,9 @@
    }
 
    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> m_8456_(int p_8457_, int p_8458_, ChunkStatus p_8459_, boolean p_8460_) {
+      return getChunkFutureMainThread(p_8457_, p_8458_, p_8459_, p_8460_, false);
+   }
+   private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int p_8457_, int p_8458_, ChunkStatus p_8459_, boolean p_8460_, boolean isUrgent) {
       ChunkPos chunkpos = new ChunkPos(p_8457_, p_8458_);
       long i = chunkpos.m_45588_();
       int j = 33 + ChunkStatus.m_62370_(p_8459_);
@@ -346,10 +_,11 @@
          boolean flag2 = this.f_8329_.m_46469_().m_46207_(GameRules.f_46134_);
          Collections.shuffle(list);
 
+         int chunksTicked = 0; // Paper
          for(ServerChunkCache.ChunkAndHolder serverchunkcache$chunkandholder : list) {
             LevelChunk levelchunk1 = serverchunkcache$chunkandholder.f_184028_;
             ChunkPos chunkpos = levelchunk1.m_7697_();
-            if (this.f_8329_.m_201916_(chunkpos) && this.f_8325_.m_183879_(chunkpos)) {
+            if ((this.f_8329_.m_201916_(chunkpos) && this.f_8325_.m_183879_(chunkpos)) || this.f_8327_.shouldForceTicks(chunkpos.m_45588_())) {
                levelchunk1.m_187632_(j);
                if (flag2 && (this.f_8335_ || this.f_8336_) && this.f_8329_.m_6857_().m_61927_(chunkpos)) {
                   NaturalSpawner.m_47029_(this.f_8329_, levelchunk1, naturalspawner$spawnstate, this.f_8336_, this.f_8335_, flag1);
@@ -357,6 +_,7 @@
 
                if (this.f_8329_.m_183438_(chunkpos.m_45588_())) {
                   this.f_8329_.m_8714_(levelchunk1, k);
+                  if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
                }
             }
          }
@@ -372,7 +_,24 @@
          });
          profilerfiller.m_7238_();
          profilerfiller.m_7238_();
+         // Paper start - controlled flush for entity tracker packets
+         List<net.minecraft.network.Connection> disabledFlushes = new java.util.ArrayList<>(this.f_8329_.f_8546_.size());
+         for (ServerPlayer player : this.f_8329_.f_8546_) {
+            net.minecraft.server.network.ServerGamePacketListenerImpl connection = player.f_8906_;
+            if (connection != null) {
+               connection.f_9742_.disableAutomaticFlush();
+               disabledFlushes.add(connection.f_9742_);
+            }
+         }
+         try { // Paper end - controlled flush for entity tracker packets
          this.f_8325_.m_140421_();
+            // Paper start - controlled flush for entity tracker packets
+         } finally {
+            for (net.minecraft.network.Connection networkManager : disabledFlushes) {
+               networkManager.enableAutomaticFlush();
+            }
+         }
+         // Paper end - controlled flush for entity tracker packets
       }
    }
 
@@ -426,11 +_,17 @@
    }
 
    public <T> void m_8387_(TicketType<T> p_8388_, ChunkPos p_8389_, int p_8390_, T p_8391_) {
-      this.f_8327_.m_140840_(p_8388_, p_8389_, p_8390_, p_8391_);
+      addRegionTicket(p_8388_, p_8389_, p_8390_, p_8391_, false);
+   }
+   public <T> void addRegionTicket(TicketType<T> p_8388_, ChunkPos p_8389_, int p_8390_, T p_8391_, boolean forceTicks) {
+      this.f_8327_.addRegionTicket(p_8388_, p_8389_, p_8390_, p_8391_, forceTicks);
    }
 
    public <T> void m_8438_(TicketType<T> p_8439_, ChunkPos p_8440_, int p_8441_, T p_8442_) {
-      this.f_8327_.m_140849_(p_8439_, p_8440_, p_8441_, p_8442_);
+      removeRegionTicket(p_8439_, p_8440_, p_8441_, p_8442_, false);
+   }
+   public <T> void removeRegionTicket(TicketType<T> p_8439_, ChunkPos p_8440_, int p_8441_, T p_8442_, boolean forceTicks) {
+      this.f_8327_.removeRegionTicket(p_8439_, p_8440_, p_8441_, p_8442_, forceTicks);
    }
 
    public void m_6692_(ChunkPos p_8400_, boolean p_8401_) {
@@ -529,11 +_,16 @@
       }
 
       public boolean m_7245_() {
-         if (ServerChunkCache.this.m_8489_()) {
-            return true;
-         } else {
-            ServerChunkCache.this.f_8331_.m_9409_();
-            return super.m_7245_();
+         try {
+            boolean execChunkTask = com.destroystokyo.paper.io.chunk.ChunkTaskManager.pollChunkWaitQueue() || ServerChunkCache.this.f_8329_.asyncChunkTaskManager.pollNextChunkTask(); // Paper
+            if (ServerChunkCache.this.m_8489_()) {
+               return true;
+            } else {
+               ServerChunkCache.this.f_8331_.m_9409_();
+               return super.m_7245_() || execChunkTask; // Paper
+            }
+         } finally {
+            f_8325_.callbackExecutor.run();
          }
       }
    }
