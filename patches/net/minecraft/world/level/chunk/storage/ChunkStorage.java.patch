--- a/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.level.chunk.storage;
 
+import ca.spottedleaf.moonrise.common.util.WorldUtil;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.serialization.MapCodec;
 import java.io.IOException;
@@ -22,20 +_,31 @@
 import net.minecraft.world.level.levelgen.structure.LegacyStructureDataHandler;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 
-public class ChunkStorage implements AutoCloseable {
+public class ChunkStorage implements AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.storage.ChunkSystemChunkStorage { // Paper - rewrite chunk system
     public static final int LAST_MONOLYTH_STRUCTURE_DATA_VERSION = 1493;
-    private final IOWorker worker;
+    //private final IOWorker worker;
     protected final DataFixer fixerUpper;
     @Nullable
     private volatile LegacyStructureDataHandler legacyStructureHandler;
 
+    // Paper start - rewrite chunk system
+    private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger();
+    private final RegionFileStorage storage;
+
+    @Override
+    public final RegionFileStorage moonrise$getRegionStorage() {
+        return this.storage;
+    }
+    // Paper end - rewrite chunk system
+
     public ChunkStorage(RegionStorageInfo p_326130_, Path p_196912_, DataFixer p_196913_, boolean p_196914_) {
         this.fixerUpper = p_196913_;
-        this.worker = new IOWorker(p_326130_, p_196912_, p_196914_);
+        this.storage = new IOWorker(p_326130_, p_196912_, p_196914_).storage; // Paper - rewrite chunk system
+
     }
 
     public boolean isOldChunkAround(ChunkPos p_223452_, int p_223453_) {
-        return this.worker.isOldChunkAround(p_223452_, p_223453_);
+        return true;
     }
 
     public CompoundTag upgradeChunkTag(
@@ -101,36 +_,73 @@
     public static int getVersion(CompoundTag p_63506_) {
         return NbtUtils.getDataVersion(p_63506_, -1);
     }
-
-    public CompletableFuture<Optional<CompoundTag>> read(ChunkPos p_223455_) {
-        return this.worker.loadAsync(p_223455_);
-    }
-
-    public CompletableFuture<Void> write(ChunkPos p_63503_, CompoundTag p_63504_) {
-        this.handleLegacyStructureIndex(p_63503_);
-        return this.worker.store(p_63503_, p_63504_);
-    }
-
-    protected void handleLegacyStructureIndex(ChunkPos p_321604_) {
+    public CompletableFuture<Optional<CompoundTag>> read(ChunkPos chunkPos) {
+        // Paper start - rewrite chunk system
+        try {
+            return CompletableFuture.completedFuture(Optional.ofNullable(this.storage.read(chunkPos)));
+        } catch (final Throwable throwable) {
+            return CompletableFuture.failedFuture(throwable);
+        }
+        // Paper end - rewrite chunk system
+    }
+
+    public CompletableFuture<Void> write(ChunkPos chunkPos, CompoundTag nbt) {
+        // Paper start - guard against serializing mismatching coordinates
+        if (nbt != null && !chunkPos.equals(ChunkSerializer.getChunkCoordinate(nbt))) {
+            final String world = (this instanceof net.minecraft.server.level.ChunkMap) ? WorldUtil.getWorldName(((net.minecraft.server.level.ChunkMap) this).level) : null;
+            throw new IllegalArgumentException("Chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + chunkPos
+                    + " but compound says coordinate is " + ChunkSerializer.getChunkCoordinate(nbt) + (world == null ? " for an unknown world" : (" for world: " + world)));
+        }
+        // Paper end - guard against serializing mismatching coordinates
+        this.handleLegacyStructureIndex(chunkPos);
+        // Paper start - rewrite chunk system
+        try {
+            this.storage.write(chunkPos, nbt);
+            return CompletableFuture.completedFuture(null);
+        } catch (final Throwable throwable) {
+            return CompletableFuture.failedFuture(throwable);
+        }
+        // Paper end - rewrite chunk system
+    }
+
+    protected void handleLegacyStructureIndex(ChunkPos chunkPos) {
         if (this.legacyStructureHandler != null) {
-            this.legacyStructureHandler.removeIndex(p_321604_.toLong());
+            synchronized (this.legacyStructureHandler) { // Paper - rewrite chunk system
+                this.legacyStructureHandler.removeIndex(chunkPos.toLong());
+            } // Paper - rewrite chunk system
         }
+
     }
 
     public void flushWorker() {
-        this.worker.synchronize(true).join();
+        // Paper start - rewrite chunk system
+        try {
+            this.storage.flush();
+        } catch (final IOException ex) {
+            LOGGER.error("Failed to flush chunk storage", ex);
+        }
+        // Paper end - rewrite chunk system
     }
 
-    @Override
     public void close() throws IOException {
-        this.worker.close();
+        this.storage.close(); // Paper - rewrite chunk system
     }
 
     public ChunkScanAccess chunkScanner() {
-        return this.worker;
+        // Paper start - rewrite chunk system
+        // TODO ChunkMap implementation?
+        return (chunkPos, streamTagVisitor) -> {
+            try {
+                this.storage.scanChunk(chunkPos, streamTagVisitor);
+                return java.util.concurrent.CompletableFuture.completedFuture(null);
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        };
+        // Paper end - rewrite chunk system
     }
 
-    protected RegionStorageInfo storageInfo() {
-        return this.worker.storageInfo();
+    public RegionStorageInfo storageInfo() { // Paper - public
+        return this.storage.info(); // Paper - rewrite chunk system
     }
 }
