--- a/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -57,14 +_,14 @@
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
 
-public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, LightChunk, StructureAccess {
+public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, LightChunk, StructureAccess, net.neoforged.neoforge.attachment.IAttachmentHolder, ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk { // Paper - rewrite chunk system
     public static final int NO_FILLED_SECTION = -1;
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final LongSet EMPTY_REFERENCE_SET = new LongOpenHashSet();
     protected final ShortList[] postProcessing;
     protected volatile boolean unsaved;
     private volatile boolean isLightCorrect;
-    protected final ChunkPos chunkPos;
+    protected final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
     private long inhabitedTime;
     @Nullable
     @Deprecated
@@ -75,7 +_,7 @@
     @Nullable
     protected BlendingData blendingData;
     protected final Map<Heightmap.Types, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Types.class);
-    protected ChunkSkyLightSources skyLightSources;
+    //protected ChunkSkyLightSources skyLightSources;
     private final Map<Structure, StructureStart> structureStarts = Maps.newHashMap();
     private final Map<Structure, LongSet> structuresRefences = Maps.newHashMap();
     protected final Map<BlockPos, CompoundTag> pendingBlockEntities = Maps.newHashMap();
@@ -83,6 +_,57 @@
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
 
+    // Paper start - rewrite chunk system
+    private volatile ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] blockNibbles;
+    private volatile ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] skyNibbles;
+    private volatile boolean[] skyEmptinessMap;
+    private volatile boolean[] blockEmptinessMap;
+
+    @Override
+    public ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] starlight$getBlockNibbles() {
+        return this.blockNibbles;
+    }
+
+    @Override
+    public void starlight$setBlockNibbles(final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] nibbles) {
+        this.blockNibbles = nibbles;
+    }
+
+    @Override
+    public ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] starlight$getSkyNibbles() {
+        return this.skyNibbles;
+    }
+
+    @Override
+    public void starlight$setSkyNibbles(final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] nibbles) {
+        this.skyNibbles = nibbles;
+    }
+
+    @Override
+    public boolean[] starlight$getSkyEmptinessMap() {
+        return this.skyEmptinessMap;
+    }
+
+    @Override
+    public void starlight$setSkyEmptinessMap(final boolean[] emptinessMap) {
+        this.skyEmptinessMap = emptinessMap;
+    }
+
+    @Override
+    public boolean[] starlight$getBlockEmptinessMap() {
+        return this.blockEmptinessMap;
+    }
+
+    @Override
+    public void starlight$setBlockEmptinessMap(final boolean[] emptinessMap) {
+        this.blockEmptinessMap = emptinessMap;
+    }
+    // Paper end - rewrite chunk system
+    // Paper start - get block chunk optimisation
+    private final int minSection;
+    private final int maxSection;
+    // Paper end - get block chunk optimisation
+
     public ChunkAccess(
         ChunkPos p_187621_,
         UpgradeData p_187622_,
@@ -92,14 +_,24 @@
         @Nullable LevelChunkSection[] p_187626_,
         @Nullable BlendingData p_187627_
     ) {
-        this.chunkPos = p_187621_;
+        this.locX = p_187621_.x; this.locZ = p_187621_.z; // Paper - reduce need for field lookups
+        this.chunkPos = p_187621_; this.coordinateKey = ChunkPos.asLong(locX, locZ); // Paper - cache long key
         this.upgradeData = p_187622_;
         this.levelHeightAccessor = p_187623_;
         this.sections = new LevelChunkSection[p_187623_.getSectionsCount()];
         this.inhabitedTime = p_187625_;
         this.postProcessing = new ShortList[p_187623_.getSectionsCount()];
         this.blendingData = p_187627_;
-        this.skyLightSources = new ChunkSkyLightSources(p_187623_);
+        // Paper start - rewrite chunk system
+        if (!((Object)this instanceof ImposterProtoChunk)) {
+            this.starlight$setBlockNibbles(ca.spottedleaf.moonrise.patches.starlight.light.StarLightEngine.getFilledEmptyLight(p_187623_));
+            this.starlight$setSkyNibbles(ca.spottedleaf.moonrise.patches.starlight.light.StarLightEngine.getFilledEmptyLight(p_187623_));
+        }
+        // Paper end - rewrite chunk system
+        // Paper start - get block chunk optimisation
+        this.minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(levelHeightAccessor);
+        this.maxSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(levelHeightAccessor);
+        // Paper end - get block chunk optimisation
         if (p_187626_ != null) {
             if (this.sections.length == p_187626_.length) {
                 System.arraycopy(p_187626_, 0, this.sections, 0, this.sections.length);
@@ -315,10 +_,19 @@
 
     @Override
     public final void findBlockLightSources(BiConsumer<BlockPos, BlockState> p_285269_) {
-        this.findBlocks(p_284897_ -> p_284897_.getLightEmission() != 0, p_285269_);
+        this.findBlocks(p_284897_ -> p_284897_.hasDynamicLightEmission() || p_284897_.getLightEmission(net.minecraft.world.level.EmptyBlockGetter.INSTANCE, BlockPos.ZERO) != 0, (p_284897_, pos) -> p_284897_.getLightEmission(this, pos) != 0, p_285269_);
     }
 
     public void findBlocks(Predicate<BlockState> p_285343_, BiConsumer<BlockPos, BlockState> p_285030_) {
+        findBlocks(p_285343_, (state, pos) -> p_285343_.test(state), p_285030_);
+    }
+
+    @Deprecated(forRemoval = true)
+    public void findBlocks(java.util.function.BiPredicate<BlockState, BlockPos> p_285343_, BiConsumer<BlockPos, BlockState> p_285030_) {
+        findBlocks(state -> p_285343_.test(state, BlockPos.ZERO), p_285343_, p_285030_);
+    }
+
+    public void findBlocks(Predicate<BlockState> p_285343_, java.util.function.BiPredicate<BlockState, BlockPos> fineFilter, BiConsumer<BlockPos, BlockState> p_285030_) {
         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
 
         for (int i = this.getMinSection(); i < this.getMaxSection(); i++) {
@@ -330,8 +_,9 @@
                     for (int k = 0; k < 16; k++) {
                         for (int l = 0; l < 16; l++) {
                             BlockState blockstate = levelchunksection.getBlockState(l, j, k);
-                            if (p_285343_.test(blockstate)) {
-                                p_285030_.accept(blockpos$mutableblockpos.setWithOffset(blockpos, l, j, k), blockstate);
+                            blockpos$mutableblockpos.setWithOffset(blockpos, l, j, k);
+                            if (fineFilter.test(blockstate, blockpos$mutableblockpos)) {
+                                p_285030_.accept(blockpos$mutableblockpos, blockstate);
                             }
                         }
                     }
@@ -466,14 +_,82 @@
     }
 
     public void initializeLightSources() {
-        this.skyLightSources.fillFrom(this);
+        // Paper - rewrite chunk system
     }
 
     @Override
     public ChunkSkyLightSources getSkyLightSources() {
-        return this.skyLightSources;
+        return null; // Paper - rewrite chunk system
     }
 
     public static record TicksToSave(SerializableTickContainer<Block> blocks, SerializableTickContainer<Fluid> fluids) {
     }
+
+    // Neo: Hook in AttachmentHolder to chunks for data storage and retrieval
+    private final net.neoforged.neoforge.attachment.AttachmentHolder.AsField attachmentHolder = new net.neoforged.neoforge.attachment.AttachmentHolder.AsField(this);
+
+    @Override
+    public boolean hasAttachments() {
+        return getAttachmentHolder().hasAttachments();
+    }
+
+    @Override
+    public boolean hasData(net.neoforged.neoforge.attachment.AttachmentType<?> type) {
+        return getAttachmentHolder().hasData(type);
+    }
+
+    @Override
+    public <T> T getData(net.neoforged.neoforge.attachment.AttachmentType<T> type) {
+        return getAttachmentHolder().getData(type);
+    }
+
+    @Override
+    public <T> java.util.Optional<T> getExistingData(net.neoforged.neoforge.attachment.AttachmentType<T> type) {
+        return getAttachmentHolder().getExistingData(type);
+    }
+
+    @Override
+    @Nullable
+    public <T> T setData(net.neoforged.neoforge.attachment.AttachmentType<T> type, T data) {
+        setUnsaved(true);
+        return getAttachmentHolder().setData(type, data);
+    }
+
+    @Override
+    @Nullable
+    public <T> T removeData(net.neoforged.neoforge.attachment.AttachmentType<T> type) {
+        setUnsaved(true);
+        return getAttachmentHolder().removeData(type);
+    }
+
+    /**
+     * <strong>FOR INTERNAL USE ONLY</strong>
+     * <p>
+     * Only public for use in {@link net.minecraft.world.level.chunk.storage.ChunkSerializer}.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    @Nullable
+    public final CompoundTag writeAttachmentsToNBT(HolderLookup.Provider provider) {
+        return getAttachmentHolder().serializeAttachments(provider);
+    }
+
+    /**
+     * <strong>FOR INTERNAL USE ONLY</strong>
+     * <p>
+     * Only public for use in {@link net.minecraft.world.level.chunk.storage.ChunkSerializer}.
+     *
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public final void readAttachmentsFromNBT(HolderLookup.Provider provider, CompoundTag tag) {
+        getAttachmentHolder().deserializeInternal(provider, tag);
+    }
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    protected net.neoforged.neoforge.attachment.AttachmentHolder.AsField getAttachmentHolder() {
+        return attachmentHolder;
+    }
+
+    // Neo: Allow for exposing the Level a chunk is tied to if available
+    @Nullable
+    public net.minecraft.world.level.Level getLevel() { return null; }
 }
