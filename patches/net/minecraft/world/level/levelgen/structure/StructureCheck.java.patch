--- a/net/minecraft/world/level/levelgen/structure/StructureCheck.java
+++ b/net/minecraft/world/level/levelgen/structure/StructureCheck.java
@@ -47,8 +_,13 @@
     private final BiomeSource biomeSource;
     private final long seed;
     private final DataFixer fixerUpper;
-    private final Long2ObjectMap<Object2IntMap<Structure>> loadedChunks = new Long2ObjectOpenHashMap<>();
-    private final Map<Structure, Long2BooleanMap> featureChecks = new HashMap<>();
+    // Paper start - rewrite chunk system
+    // make sure to purge entries from the maps to prevent memory leaks
+    private static final int CHUNK_TOTAL_LIMIT = 50 * (2 * 100 + 1) * (2 * 100 + 1); // cache 50 structure lookups
+    private static final int PER_FEATURE_CHECK_LIMIT = 50 * (2 * 100 + 1) * (2 * 100 + 1); // cache 50 structure lookups
+    private final ca.spottedleaf.moonrise.common.map.SynchronisedLong2ObjectMap<it.unimi.dsi.fastutil.objects.Object2IntMap<Structure>> loadedChunksSafe = new ca.spottedleaf.moonrise.common.map.SynchronisedLong2ObjectMap<>(CHUNK_TOTAL_LIMIT);
+    private final java.util.concurrent.ConcurrentHashMap<Structure, ca.spottedleaf.moonrise.common.map.SynchronisedLong2BooleanMap> featureChecksSafe = new java.util.concurrent.ConcurrentHashMap<>();
+    // Paper end - rewrite chunk system
 
     public StructureCheck(
         ChunkScanAccess p_226712_,
@@ -76,7 +_,7 @@
 
     public StructureCheckResult checkStart(ChunkPos p_226730_, Structure p_226731_, StructurePlacement p_321610_, boolean p_226732_) {
         long i = p_226730_.toLong();
-        Object2IntMap<Structure> object2intmap = this.loadedChunks.get(i);
+        Object2IntMap<Structure> object2intmap = this.loadedChunksSafe.get(i); // Paper - rewrite chunk system
         if (object2intmap != null) {
             return this.checkStructureInfo(object2intmap, p_226731_, p_226732_);
         } else {
@@ -86,9 +_,11 @@
             } else if (!p_321610_.applyAdditionalChunkRestrictions(p_226730_.x, p_226730_.z, this.seed)) {
                 return StructureCheckResult.START_NOT_PRESENT;
             } else {
-                boolean flag = this.featureChecks
-                    .computeIfAbsent(p_226731_, p_226739_ -> new Long2BooleanOpenHashMap())
-                    .computeIfAbsent(i, p_226728_ -> this.canCreateStructure(p_226730_, p_226731_));
+                // Paper start - rewrite chunk system
+                boolean flag = this.featureChecksSafe
+                        .computeIfAbsent(p_226731_, structure2 -> new ca.spottedleaf.moonrise.common.map.SynchronisedLong2BooleanMap(PER_FEATURE_CHECK_LIMIT))
+                        .getOrCompute(i, chunkPos -> this.canCreateStructure(p_226730_, p_226731_));
+                // Paper end - rewrite chunk system
                 return !flag ? StructureCheckResult.START_NOT_PRESENT : StructureCheckResult.CHUNK_LOAD_NEEDED;
             }
         }
@@ -213,19 +_,29 @@
         this.storeFullResults(i, object2intmap);
     }
 
-    private void storeFullResults(long p_197264_, Object2IntMap<Structure> p_197265_) {
-        this.loadedChunks.put(p_197264_, deduplicateEmptyMap(p_197265_));
-        this.featureChecks.values().forEach(p_209956_ -> p_209956_.remove(p_197264_));
+    private void storeFullResults(long pos, Object2IntMap<Structure> referencesByStructure) {
+        // Paper start - rewrite chunk system
+        this.loadedChunksSafe.put(pos, deduplicateEmptyMap(referencesByStructure));
+        // once we insert into loadedChunks, we don't really need to be very careful about removing everything
+        // from this map, as everything that checks this map uses loadedChunks first
+        // so, one way or another it's a race condition that doesn't matter
+        for (ca.spottedleaf.moonrise.common.map.SynchronisedLong2BooleanMap value : this.featureChecksSafe.values()) {
+            value.remove(pos);
+        }
+        // Paper end - rewrite chunk system
     }
 
-    public void incrementReference(ChunkPos p_226723_, Structure p_226724_) {
-        this.loadedChunks.compute(p_226723_.toLong(), (p_226745_, p_226746_) -> {
-            if (p_226746_ == null || p_226746_.isEmpty()) {
-                p_226746_ = new Object2IntOpenHashMap<>();
+    public void incrementReference(ChunkPos pos, Structure structure) {
+        this.loadedChunksSafe.compute(pos.toLong(), (posx, referencesByStructure) -> { // Paper start - rewrite chunk system
+            if (referencesByStructure == null) {
+                referencesByStructure = new Object2IntOpenHashMap<>();
+            } else {
+                referencesByStructure = referencesByStructure instanceof Object2IntOpenHashMap<Structure> fastClone ? fastClone.clone() : new Object2IntOpenHashMap<>(referencesByStructure);
             }
+            // Paper end - rewrite chunk system
 
-            p_226746_.computeInt(p_226724_, (p_226741_, p_226742_) -> p_226742_ == null ? 1 : p_226742_ + 1);
-            return p_226746_;
+            referencesByStructure.computeInt(structure, (feature, references) -> references == null ? 1 : references + 1);
+            return referencesByStructure;
         });
     }
 }
