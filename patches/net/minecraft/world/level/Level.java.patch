--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -3,12 +_,16 @@
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.WorldConfiguration;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -26,6 +_,7 @@
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
@@ -56,6 +_,7 @@
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkSource;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.dimension.DimensionType;
@@ -74,9 +_,10 @@
 import net.minecraft.world.level.storage.WritableLevelData;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.Scoreboard;
 
-public abstract class Level implements LevelAccessor, AutoCloseable {
+public abstract class Level extends net.neoforged.neoforge.attachment.AttachmentHolder implements LevelAccessor, AutoCloseable, net.neoforged.neoforge.common.extensions.ILevelExtension, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter, ca.spottedleaf.moonrise.patches.collisions.world.CollisionLevel {
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("the_nether"));
@@ -105,6 +_,7 @@
     @Deprecated
     private final RandomSource threadSafeRandom = RandomSource.createThreadSafe();
     private final Holder<DimensionType> dimensionTypeRegistration;
+    private final WorldConfiguration paperWorldConfigCreator;
     protected final WritableLevelData levelData;
     private final Supplier<ProfilerFiller> profiler;
     public final boolean isClientSide;
@@ -114,6 +_,499 @@
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private long subTickCount;
+    public boolean restoringBlockSnapshots = false;
+    public boolean captureBlockSnapshots = false;
+    public java.util.ArrayList<net.neoforged.neoforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<>();
+    private final java.util.ArrayList<BlockEntity> freshBlockEntities = new java.util.ArrayList<>();
+    private final java.util.ArrayList<BlockEntity> pendingFreshBlockEntities = new java.util.ArrayList<>();
+
+    // Paper start
+    public int wakeupInactiveRemainingAnimals;
+    public int wakeupInactiveRemainingFlying;
+    public int wakeupInactiveRemainingMonsters;
+    public int wakeupInactiveRemainingVillagers;
+    // Paper end
+    // Paper start - add paper world config
+    private final io.papermc.paper.configuration.WorldConfiguration paperConfig;
+    public io.papermc.paper.configuration.WorldConfiguration paperConfig() {
+        return this.paperConfig;
+    }
+    // Paper end - add paper world config
+
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    // Paper start - rewrite chunk system
+    private ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup entityLookup;
+
+    @Override
+    public final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup moonrise$getEntityLookup() {
+        return this.entityLookup;
+    }
+
+    @Override
+    public void moonrise$setEntityLookup(final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup entityLookup) {
+        if (this.entityLookup != null && !(this.entityLookup instanceof ca.spottedleaf.moonrise.patches.chunk_system.level.entity.dfl.DefaultEntityLookup)) {
+            throw new IllegalStateException("Entity lookup already initialised");
+        }
+        this.entityLookup = entityLookup;
+    }
+
+    @Override
+    public final <T extends Entity> List<T> getEntitiesOfClass(final Class<T> entityClass, final AABB boundingBox, final Predicate<? super T> predicate) {
+        this.getProfiler().incrementCounter("getEntities");
+        final List<T> ret = new java.util.ArrayList<>();
+
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(entityClass, null, boundingBox, ret, predicate);
+
+        return ret;
+    }
+
+    @Override
+    public final List<Entity> moonrise$getHardCollidingEntities(final Entity entity, final AABB box, final Predicate<? super Entity> predicate) {
+        this.getProfiler().incrementCounter("getEntities");
+        final List<Entity> ret = new java.util.ArrayList<>();
+
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getHardCollidingEntities(entity, box, ret, predicate);
+
+        return ret;
+    }
+
+    @Override
+    public final boolean hasChunkAt(BlockPos pos) {
+        return getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4) != null; // Paper - Perf: Optimize Level.hasChunkAt(BlockPosition)Z
+    }
+
+    public final boolean isLoadedAndInBounds(BlockPos blockposition) { // Paper - final for inline
+        return getWorldBorder().isWithinBounds(blockposition) && getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4) != null;
+    }
+
+    public @Nullable LevelChunk getChunkIfLoaded(int x, int z) { // Overridden in WorldServer for ABI compat which has final
+        return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(x, z);
+    }
+
+    @Override
+    public LevelChunk moonrise$getFullChunkIfLoaded(final int chunkX, final int chunkZ) {
+        return this.getChunkSource().getChunk(chunkX, chunkZ, false);
+    }
+
+    @Override
+    public ChunkAccess moonrise$getAnyChunkIfLoaded(final int chunkX, final int chunkZ) {
+        return this.getChunkSource().getChunk(chunkX, chunkZ, ChunkStatus.EMPTY, false);
+    }
+
+    @Override
+    public ChunkAccess moonrise$getSpecificChunkIfLoaded(final int chunkX, final int chunkZ, final ChunkStatus leastStatus) {
+        return this.getChunkSource().getChunk(chunkX, chunkZ, leastStatus, false);
+    }
+
+    @Override
+    public void moonrise$midTickTasks() {
+        // no-op on ClientLevel
+    }
+    /**
+     * @reason Turn all getChunk(x, z, status) calls into virtual invokes, instead of interface invokes:
+     *         1. The interface invoke is expensive
+     *         2. The method makes other interface invokes (again, expensive)
+     *         Instead, we just directly call getChunk(x, z, status, true) which avoids the interface invokes entirely.
+     * @author Spottedleaf
+     */
+    @Override
+    public ChunkAccess getChunk(final int x, final int z, final ChunkStatus status) {
+        return ((Level)(Object)this).getChunk(x, z, status, true);
+    }
+
+    @Override
+    public BlockPos getHeightmapPos(Heightmap.Types types, BlockPos blockPos) {
+        return new BlockPos(blockPos.getX(), this.getHeight(types, blockPos.getX(), blockPos.getZ()), blockPos.getZ());
+    }
+    // Paper end - rewrite chunk system
+    // Paper start - optimise collisions
+    private final int minSection;
+    private final int maxSection;
+
+    @Override
+    public final int moonrise$getMinSection() {
+        return this.minSection;
+    }
+
+    @Override
+    public final int moonrise$getMaxSection() {
+        return this.maxSection;
+    }
+
+    /**
+     * Route to faster lookup.
+     * See {@link EntityGetter#isUnobstructed(Entity, VoxelShape)} for expected behavior
+     * @author Spottedleaf
+     */
+    @Override
+    public final boolean isUnobstructed(final Entity entity) {
+        final AABB boundingBox = entity.getBoundingBox();
+        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isEmpty(boundingBox)) {
+            return false;
+        }
+
+        final List<Entity> entities = this.getEntities(
+                entity,
+                boundingBox.inflate(-ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON),
+                null
+        );
+
+        for (int i = 0, len = entities.size(); i < len; ++i) {
+            final Entity otherEntity = entities.get(i);
+
+            if (otherEntity.isSpectator() || otherEntity.isRemoved() || !otherEntity.blocksBuilding || otherEntity.isPassengerOfSameVehicle(entity)) {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+
+
+    private static net.minecraft.world.phys.BlockHitResult miss(final ClipContext clipContext) {
+        final Vec3 to = clipContext.getTo();
+        final Vec3 from = clipContext.getFrom();
+
+        return net.minecraft.world.phys.BlockHitResult.miss(to, Direction.getNearest(from.x - to.x, from.y - to.y, from.z - to.z), BlockPos.containing(to.x, to.y, to.z));
+    }
+
+    private static final FluidState AIR_FLUIDSTATE = Fluids.EMPTY.defaultFluidState();
+
+    private static net.minecraft.world.phys.BlockHitResult fastClip(final Vec3 from, final Vec3 to, final Level level,
+                                                                    final ClipContext clipContext) {
+        final double adjX = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON * (from.x - to.x);
+        final double adjY = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON * (from.y - to.y);
+        final double adjZ = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON * (from.z - to.z);
+
+        if (adjX == 0.0 && adjY == 0.0 && adjZ == 0.0) {
+            return miss(clipContext);
+        }
+
+        final double toXAdj = to.x - adjX;
+        final double toYAdj = to.y - adjY;
+        final double toZAdj = to.z - adjZ;
+        final double fromXAdj = from.x + adjX;
+        final double fromYAdj = from.y + adjY;
+        final double fromZAdj = from.z + adjZ;
+
+        int currX = Mth.floor(fromXAdj);
+        int currY = Mth.floor(fromYAdj);
+        int currZ = Mth.floor(fromZAdj);
+
+        final BlockPos.MutableBlockPos currPos = new BlockPos.MutableBlockPos();
+
+        final double diffX = toXAdj - fromXAdj;
+        final double diffY = toYAdj - fromYAdj;
+        final double diffZ = toZAdj - fromZAdj;
+
+        final double dxDouble = Math.signum(diffX);
+        final double dyDouble = Math.signum(diffY);
+        final double dzDouble = Math.signum(diffZ);
+
+        final int dx = (int)dxDouble;
+        final int dy = (int)dyDouble;
+        final int dz = (int)dzDouble;
+
+        final double normalizedDiffX = diffX == 0.0 ? Double.MAX_VALUE : dxDouble / diffX;
+        final double normalizedDiffY = diffY == 0.0 ? Double.MAX_VALUE : dyDouble / diffY;
+        final double normalizedDiffZ = diffZ == 0.0 ? Double.MAX_VALUE : dzDouble / diffZ;
+
+        double normalizedCurrX = normalizedDiffX * (diffX > 0.0 ? (1.0 - Mth.frac(fromXAdj)) : Mth.frac(fromXAdj));
+        double normalizedCurrY = normalizedDiffY * (diffY > 0.0 ? (1.0 - Mth.frac(fromYAdj)) : Mth.frac(fromYAdj));
+        double normalizedCurrZ = normalizedDiffZ * (diffZ > 0.0 ? (1.0 - Mth.frac(fromZAdj)) : Mth.frac(fromZAdj));
+
+        net.minecraft.world.level.chunk.LevelChunkSection[] lastChunk = null;
+        net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> lastSection = null;
+        int lastChunkX = Integer.MIN_VALUE;
+        int lastChunkY = Integer.MIN_VALUE;
+        int lastChunkZ = Integer.MIN_VALUE;
+
+        final int minSection = ((ca.spottedleaf.moonrise.patches.collisions.world.CollisionLevel)level).moonrise$getMinSection();
+
+        for (;;) {
+            currPos.set(currX, currY, currZ);
+
+            final int newChunkX = currX >> 4;
+            final int newChunkY = currY >> 4;
+            final int newChunkZ = currZ >> 4;
+
+            final int chunkDiff = ((newChunkX ^ lastChunkX) | (newChunkZ ^ lastChunkZ));
+            final int chunkYDiff = newChunkY ^ lastChunkY;
+
+            if ((chunkDiff | chunkYDiff) != 0) {
+                if (chunkDiff != 0) {
+                    lastChunk = level.getChunk(newChunkX, newChunkZ).getSections();
+                }
+                final int sectionY = newChunkY - minSection;
+                lastSection = sectionY >= 0 && sectionY < lastChunk.length ? lastChunk[sectionY].states : null;
+
+                lastChunkX = newChunkX;
+                lastChunkY = newChunkY;
+                lastChunkZ = newChunkZ;
+            }
+
+            final BlockState blockState;
+            if (lastSection != null && !(blockState = lastSection.get((currX & 15) | ((currZ & 15) << 4) | ((currY & 15) << (4+4)))).isAir()) {
+                final VoxelShape blockCollision = clipContext.getBlockShape(blockState, level, currPos);
+
+                final net.minecraft.world.phys.BlockHitResult blockHit = blockCollision.isEmpty() ? null : level.clipWithInteractionOverride(from, to, currPos, blockCollision, blockState);
+
+                final VoxelShape fluidCollision;
+                final FluidState fluidState;
+                if (clipContext.fluid != ClipContext.Fluid.NONE && (fluidState = blockState.getFluidState()) != AIR_FLUIDSTATE) {
+                    fluidCollision = clipContext.getFluidShape(fluidState, level, currPos);
+
+                    final net.minecraft.world.phys.BlockHitResult fluidHit = fluidCollision.clip(from, to, currPos);
+
+                    if (fluidHit != null) {
+                        if (blockHit == null) {
+                            return fluidHit;
+                        }
+
+                        return from.distanceToSqr(blockHit.getLocation()) <= from.distanceToSqr(fluidHit.getLocation()) ? blockHit : fluidHit;
+                    }
+                }
+
+                if (blockHit != null) {
+                    return blockHit;
+                }
+            } // else: usually fall here
+
+            if (normalizedCurrX > 1.0 && normalizedCurrY > 1.0 && normalizedCurrZ > 1.0) {
+                return miss(clipContext);
+            }
+
+            // inc the smallest normalized coordinate
+
+            if (normalizedCurrX < normalizedCurrY) {
+                if (normalizedCurrX < normalizedCurrZ) {
+                    currX += dx;
+                    normalizedCurrX += normalizedDiffX;
+                } else {
+                    // x < y && x >= z <--> z < y && z <= x
+                    currZ += dz;
+                    normalizedCurrZ += normalizedDiffZ;
+                }
+            } else if (normalizedCurrY < normalizedCurrZ) {
+                // y <= x && y < z
+                currY += dy;
+                normalizedCurrY += normalizedDiffY;
+            } else {
+                // y <= x && z <= y <--> z <= y && z <= x
+                currZ += dz;
+                normalizedCurrZ += normalizedDiffZ;
+            }
+        }
+    }
+
+    /**
+     * @reason Route to optimized call
+     * @author Spottedleaf
+     */
+    @Override
+    public final net.minecraft.world.phys.BlockHitResult clip(final ClipContext clipContext) {
+        // can only do this in this class, as not everything that implements BlockGetter can retrieve chunks
+        return fastClip(clipContext.getFrom(), clipContext.getTo(), (Level)(Object)this, clipContext);
+    }
+
+    /**
+     * @reason Route to faster logic
+     * @author Spottedleaf
+     */
+    @Override
+    public final boolean collidesWithSuffocatingBlock(final Entity entity, final AABB box) {
+        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level)(Object)this, entity, box, null, null,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY,
+                (final BlockState state, final BlockPos pos) -> {
+                    return state.isSuffocating((Level)(Object)Level.this, pos);
+                }
+        );
+    }
+
+    private static VoxelShape inflateAABBToVoxel(final AABB aabb, final double x, final double y, final double z) {
+        return net.minecraft.world.phys.shapes.Shapes.create(
+                aabb.minX - x,
+                aabb.minY - y,
+                aabb.minZ - z,
+
+                aabb.maxX + x,
+                aabb.maxY + y,
+                aabb.maxZ + z
+        );
+    }
+
+    /**
+     * @reason Use optimised OR operator join strategy, avoid streams
+     * @author Spottedleaf
+     */
+    @Override
+    public final java.util.Optional<net.minecraft.world.phys.Vec3> findFreePosition(final Entity entity, final VoxelShape boundsShape, final Vec3 fromPosition,
+                                                                                    final double rangeX, final double rangeY, final double rangeZ) {
+        if (boundsShape.isEmpty()) {
+            return java.util.Optional.empty();
+        }
+
+        final double expandByX = rangeX * 0.5;
+        final double expandByY = rangeY * 0.5;
+        final double expandByZ = rangeZ * 0.5;
+
+        // note: it is useless to look at shapes outside of range / 2.0
+        final AABB collectionVolume = boundsShape.bounds().inflate(expandByX, expandByY, expandByZ);
+
+        final List<AABB> aabbs = new java.util.ArrayList<>();
+        final List<VoxelShape> voxels = new java.util.ArrayList<>();
+
+        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
+                (Level)(Object)this, entity, collectionVolume, voxels, aabbs,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+                null
+        );
+
+        final WorldBorder worldBorder = this.getWorldBorder();
+        if (worldBorder != null) {
+            aabbs.removeIf((final AABB aabb) -> {
+                return !worldBorder.isWithinBounds(aabb);
+            });
+            voxels.removeIf((final VoxelShape shape) -> {
+                return !worldBorder.isWithinBounds(shape.bounds());
+            });
+        }
+
+        // push voxels into aabbs
+        for (int i = 0, len = voxels.size(); i < len; ++i) {
+            aabbs.addAll(voxels.get(i).toAabbs());
+        }
+
+        // expand AABBs
+        final VoxelShape first = aabbs.isEmpty() ? net.minecraft.world.phys.shapes.Shapes.empty() : inflateAABBToVoxel(aabbs.get(0), expandByX, expandByY, expandByZ);
+        final VoxelShape[] rest = new VoxelShape[Math.max(0, aabbs.size() - 1)];
+
+        for (int i = 1, len = aabbs.size(); i < len; ++i) {
+            rest[i - 1] = inflateAABBToVoxel(aabbs.get(i), expandByX, expandByY, expandByZ);
+        }
+
+        // use optimized implementation of ORing the shapes together
+        final VoxelShape joined = net.minecraft.world.phys.shapes.Shapes.or(first, rest);
+
+        // find free space
+        // can use unoptimized join here (instead of join()), as closestPointTo uses toAabbs()
+        final VoxelShape freeSpace = net.minecraft.world.phys.shapes.Shapes.joinUnoptimized(boundsShape, joined, net.minecraft.world.phys.shapes.BooleanOp.ONLY_FIRST);
+
+        return freeSpace.closestPointTo(fromPosition);
+    }
+
+    /**
+     * @reason Route to faster logic
+     * @author Spottedleaf
+     */
+    @Override
+    public final java.util.Optional<net.minecraft.core.BlockPos> findSupportingBlock(final Entity entity, final AABB aabb) {
+        final int minBlockX = Mth.floor(aabb.minX - ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON) - 1;
+        final int maxBlockX = Mth.floor(aabb.maxX + ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON) + 1;
+
+        final int minBlockY = Mth.floor(aabb.minY - ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON) - 1;
+        final int maxBlockY = Mth.floor(aabb.maxY + ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON) + 1;
+
+        final int minBlockZ = Mth.floor(aabb.minZ - ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON) - 1;
+        final int maxBlockZ = Mth.floor(aabb.maxZ + ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON) + 1;
+
+        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.LazyEntityCollisionContext collisionContext = null;
+
+        final BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();
+        BlockPos selected = null;
+        double selectedDistance = Double.MAX_VALUE;
+
+        final Vec3 entityPos = entity.position();
+
+        LevelChunk lastChunk = null;
+        int lastChunkX = Integer.MIN_VALUE;
+        int lastChunkZ = Integer.MIN_VALUE;
+
+        final ChunkSource chunkSource = this.getChunkSource();
+
+        for (int currZ = minBlockZ; currZ <= maxBlockZ; ++currZ) {
+            pos.setZ(currZ);
+            for (int currX = minBlockX; currX <= maxBlockX; ++currX) {
+                pos.setX(currX);
+
+                final int newChunkX = currX >> 4;
+                final int newChunkZ = currZ >> 4;
+
+                if (((newChunkX ^ lastChunkX) | (newChunkZ ^ lastChunkZ)) != 0) {
+                    lastChunkX = newChunkX;
+                    lastChunkZ = newChunkZ;
+                    lastChunk = (LevelChunk)chunkSource.getChunk(newChunkX, newChunkZ, ChunkStatus.FULL, false);
+                }
+
+                if (lastChunk == null) {
+                    continue;
+                }
+                for (int currY = minBlockY; currY <= maxBlockY; ++currY) {
+                    int edgeCount = ((currX == minBlockX || currX == maxBlockX) ? 1 : 0) +
+                            ((currY == minBlockY || currY == maxBlockY) ? 1 : 0) +
+                            ((currZ == minBlockZ || currZ == maxBlockZ) ? 1 : 0);
+                    if (edgeCount == 3) {
+                        continue;
+                    }
+
+                    pos.setY(currY);
+
+                    final double distance = pos.distToCenterSqr(entityPos);
+                    if (distance > selectedDistance || (distance == selectedDistance && selected.compareTo(pos) >= 0)) {
+                        continue;
+                    }
+
+                    final BlockState state = ((ca.spottedleaf.moonrise.patches.chunk_getblock.GetBlockChunk)lastChunk).moonrise$getBlock(currX, currY, currZ);
+                    if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)state).moonrise$emptyCollisionShape()) {
+                        continue;
+                    }
+
+                    VoxelShape blockCollision = ((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)state).moonrise$getConstantCollisionShape();
+
+                    if ((edgeCount != 1 || state.hasLargeCollisionShape()) && (edgeCount != 2 || state.getBlock() == Blocks.MOVING_PISTON)) {
+                        if (collisionContext == null) {
+                            collisionContext = new ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.LazyEntityCollisionContext(entity);
+                        }
+
+                        if (blockCollision == null) {
+                            blockCollision = state.getCollisionShape((Level)(Object)this, pos, collisionContext);
+                        }
+
+                        if (blockCollision.isEmpty()) {
+                            continue;
+                        }
+
+                        // avoid VoxelShape#move by shifting the entity collision shape instead
+                        final AABB shiftedAABB = aabb.move(-(double)currX, -(double)currY, -(double)currZ);
+
+                        final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)blockCollision).moonrise$getSingleAABBRepresentation();
+                        if (singleAABB != null) {
+                            if (!ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersect(singleAABB, shiftedAABB)) {
+                                continue;
+                            }
+
+                            selected = pos.immutable();
+                            selectedDistance = distance;
+                            continue;
+                        }
+
+                        if (!ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersectNoEmpty(blockCollision, shiftedAABB)) {
+                            continue;
+                        }
+
+                        selected = pos.immutable();
+                        selectedDistance = distance;
+                        continue;
+                    }
+                }
+            }
+        }
+
+        return java.util.Optional.ofNullable(selected);
+    }
+    // Paper end - optimise collisions
 
     protected Level(
         WritableLevelData p_270739_,
@@ -124,11 +_,14 @@
         boolean p_270904_,
         boolean p_270470_,
         long p_270248_,
-        int p_270466_
+        int p_270466_,
+        io.papermc.paper.configuration.WorldConfiguration paperWorldConfigCreator
     ) {
+        this.paperConfig = paperWorldConfigCreator; // Paper - create paper world config
         this.profiler = p_270692_;
         this.levelData = p_270739_;
         this.dimensionTypeRegistration = p_270240_;
+        this.paperWorldConfigCreator = paperWorldConfigCreator;
         final DimensionType dimensiontype = p_270240_.value();
         this.dimension = p_270683_;
         this.isClientSide = p_270904_;
@@ -154,6 +_,12 @@
         this.neighborUpdater = new CollectingNeighborUpdater(this, p_270466_);
         this.registryAccess = p_270200_;
         this.damageSources = new DamageSources(p_270200_);
+
+        this.entityLookup = new ca.spottedleaf.moonrise.patches.chunk_system.level.entity.dfl.DefaultEntityLookup(this); // Paper - rewrite chunk system
+        // Paper start - optimise collisions
+        this.minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(this);
+        this.maxSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(this);
+        // Paper end - optimise collisions
     }
 
     @Override
@@ -188,7 +_,14 @@
     }
 
     public LevelChunk getChunk(int p_46727_, int p_46728_) {
-        return (LevelChunk)this.getChunk(p_46727_, p_46728_, ChunkStatus.FULL);
+        // Paper start - Perf: make sure loaded chunks get the inlined variant of this function
+        net.minecraft.server.level.ServerChunkCache cps = ((ServerLevel)this).getChunkSource();
+        LevelChunk ifLoaded = cps.getChunkAtIfLoadedImmediately(p_46727_, p_46728_);
+        if (ifLoaded != null) {
+            return ifLoaded;
+        }
+        return (LevelChunk) cps.getChunk(p_46727_, p_46728_, ChunkStatus.FULL, true); // Paper - avoid a method jump
+        // Paper end - Perf: make sure loaded chunks get the inlined variant of this function
     }
 
     @Nullable
@@ -202,6 +_,40 @@
         }
     }
 
+    // Paper start - if loaded
+    @Nullable
+    @Override
+    public final ChunkAccess getChunkIfLoadedImmediately(int x, int z) {
+        return ((ServerLevel)this).chunkSource.getChunkAtIfLoadedImmediately(x, z);
+    }
+
+    @Override
+    @Nullable
+    public final BlockState getBlockStateIfLoaded(BlockPos pos) {
+        if (this.isOutsideBuildHeight(pos)) {
+            return Blocks.VOID_AIR.defaultBlockState();
+        } else {
+            ChunkAccess chunk = this.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4);
+
+            return chunk == null ? null : chunk.getBlockState(pos);
+        }
+    }
+
+    @Override
+    public final FluidState getFluidIfLoaded(BlockPos blockposition) {
+        ChunkAccess chunk = this.getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+
+        return chunk == null ? null : chunk.getFluidState(blockposition);
+    }
+
+    public final @Nullable LevelChunk getChunkIfLoaded(BlockPos blockposition) {
+        return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+
+    //  reduces need to do isLoaded before getType
+    public final @Nullable BlockState getBlockStateIfLoadedAndInBounds(BlockPos blockposition) {
+        return getWorldBorder().isWithinBounds(blockposition) ? getBlockStateIfLoaded(blockposition) : null;
+    }
     @Override
     public boolean setBlock(BlockPos p_46601_, BlockState p_46602_, int p_46603_) {
         return this.setBlock(p_46601_, p_46602_, p_46603_, 512);
@@ -216,11 +_,40 @@
         } else {
             LevelChunk levelchunk = this.getChunkAt(p_46605_);
             Block block = p_46606_.getBlock();
+
+            p_46605_ = p_46605_.immutable(); // Forge - prevent mutable BlockPos leaks
+            net.neoforged.neoforge.common.util.BlockSnapshot blockSnapshot = null;
+            if (this.captureBlockSnapshots && !this.isClientSide) {
+                 blockSnapshot = net.neoforged.neoforge.common.util.BlockSnapshot.create(this.dimension, this, p_46605_, p_46607_);
+                 this.capturedBlockSnapshots.add(blockSnapshot);
+            }
+
+            BlockState old = getBlockState(p_46605_);
+            int oldLight = old.getLightEmission(this, p_46605_);
+            int oldOpacity = old.getLightBlock(this, p_46605_);
+
             BlockState blockstate = levelchunk.setBlockState(p_46605_, p_46606_, (p_46607_ & 64) != 0);
             if (blockstate == null) {
+                if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
                 return false;
             } else {
                 BlockState blockstate1 = this.getBlockState(p_46605_);
+
+                if (blockSnapshot == null) { // Don't notify clients or update physics while capturing blockstates
+                    this.markAndNotifyBlock(p_46605_, levelchunk, blockstate, p_46606_, p_46607_, p_46608_);
+                }
+
+                return true;
+            }
+        }
+    }
+
+    // Split off from original setBlockState(BlockPos, BlockState, int, int) method in order to directly send client and physic updates
+    public void markAndNotifyBlock(BlockPos p_46605_, @Nullable LevelChunk levelchunk, BlockState blockstate, BlockState p_46606_, int p_46607_, int p_46608_) {
+        Block block = p_46606_.getBlock();
+        BlockState blockstate1 = getBlockState(p_46605_);
+        {
+            {
                 if (blockstate1 == p_46606_) {
                     if (blockstate != blockstate1) {
                         this.setBlocksDirty(p_46605_, blockstate, blockstate1);
@@ -247,9 +_,8 @@
                     }
 
                     this.onBlockStateChange(p_46605_, blockstate, blockstate1);
+                    p_46606_.onBlockStateChange(this, p_46605_, blockstate);
                 }
-
-                return true;
             }
         }
     }
@@ -301,6 +_,7 @@
     }
 
     public void updateNeighborsAt(BlockPos p_46673_, Block p_46674_) {
+        net.neoforged.neoforge.event.EventHooks.onNeighborNotify(this, p_46673_, this.getBlockState(p_46673_), java.util.EnumSet.allOf(Direction.class), false).isCanceled();
     }
 
     public void updateNeighborsAtExceptFromFacing(BlockPos p_46591_, Block p_46592_, Direction p_46593_) {
@@ -489,10 +_,26 @@
         (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(p_151526_);
     }
 
+    public void addFreshBlockEntities(java.util.Collection<BlockEntity> beList) {
+        if (this.tickingBlockEntities) {
+            this.pendingFreshBlockEntities.addAll(beList);
+        } else {
+            this.freshBlockEntities.addAll(beList);
+        }
+    }
+
     protected void tickBlockEntities() {
         ProfilerFiller profilerfiller = this.getProfiler();
         profilerfiller.push("blockEntities");
+        if (!this.pendingFreshBlockEntities.isEmpty()) {
+            this.freshBlockEntities.addAll(this.pendingFreshBlockEntities);
+            this.pendingFreshBlockEntities.clear();
+        }
         this.tickingBlockEntities = true;
+        if (!this.freshBlockEntities.isEmpty()) {
+            this.freshBlockEntities.forEach(BlockEntity::onLoad);
+            this.freshBlockEntities.clear();
+        }
         if (!this.pendingBlockEntityTickers.isEmpty()) {
             this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
             this.pendingBlockEntityTickers.clear();
@@ -516,14 +_,36 @@
 
     public <T extends Entity> void guardEntityTick(Consumer<T> p_46654_, T p_46655_) {
         try {
+            net.neoforged.neoforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(p_46655_);
             p_46654_.accept(p_46655_);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking entity");
             CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being ticked");
             p_46655_.fillCrashReportCategory(crashreportcategory);
+            if (net.neoforged.neoforge.common.NeoForgeConfig.SERVER.removeErroringEntities.get()) {
+                com.mojang.logging.LogUtils.getLogger().error("{}", crashreport.getFriendlyReport(net.minecraft.ReportType.CRASH));
+                p_46655_.discard();
+            } else
             throw new ReportedException(crashreport);
-        }
-    }
+        } finally {
+            net.neoforged.neoforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(p_46655_);
+        }
+    }
+
+    // Paper start - Option to prevent armor stands from doing entity lookups
+    @Override
+    public boolean noCollision(@Nullable Entity entity, AABB box) {
+        if (entity instanceof net.minecraft.world.entity.decoration.ArmorStand && !entity.level().paperConfig().entities.armorStands.doCollisionEntityLookups) return false;
+        // Paper start - optimise collisions
+        final int flags = entity == null ? (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER | ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY) : ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY;
+        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level)(Object)this, entity, box, null, null, flags, null)) {
+            return false;
+        }
+
+        return !ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions((Level)(Object)this, entity, box, null, flags, null);
+        // Paper end - optimise collisions
+    }
+    // Paper end - Option to prevent armor stands from doing entity lookups
 
     public boolean shouldTickDeath(Entity p_186458_) {
         return true;
@@ -670,7 +_,7 @@
         Explosion.BlockInteraction explosion$blockinteraction = switch (p_312265_) {
             case NONE -> Explosion.BlockInteraction.KEEP;
             case BLOCK -> this.getDestroyType(GameRules.RULE_BLOCK_EXPLOSION_DROP_DECAY);
-            case MOB -> this.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)
+            case MOB -> net.neoforged.neoforge.event.EventHooks.canEntityGrief(this, p_311934_)
             ? this.getDestroyType(GameRules.RULE_MOB_EXPLOSION_DROP_DECAY)
             : Explosion.BlockInteraction.KEEP;
             case TNT -> this.getDestroyType(GameRules.RULE_TNT_EXPLOSION_DROP_DECAY);
@@ -691,6 +_,7 @@
             p_312060_,
             p_320283_
         );
+        if (net.neoforged.neoforge.event.EventHooks.onExplosionStart(this, explosion)) return explosion;
         explosion.explode();
         explosion.finalizeExplosion(p_312145_);
         return explosion;
@@ -725,6 +_,7 @@
         if (!this.isOutsideBuildHeight(p_46748_)) {
             this.getChunkAt(p_46748_).removeBlockEntity(p_46748_);
         }
+        this.updateNeighbourForOutputSignal(p_46748_, getBlockState(p_46748_).getBlock()); //Notify neighbors of changes
     }
 
     public boolean isLoaded(BlockPos p_46750_) {
@@ -795,23 +_,15 @@
     }
 
     @Override
-    public List<Entity> getEntities(@Nullable Entity p_46536_, AABB p_46537_, Predicate<? super Entity> p_46538_) {
+    public List<Entity> getEntities(@Nullable Entity except, AABB box, Predicate<? super Entity> predicate) {
         this.getProfiler().incrementCounter("getEntities");
-        List<Entity> list = Lists.newArrayList();
-        this.getEntities().get(p_46537_, p_151522_ -> {
-            if (p_151522_ != p_46536_ && p_46538_.test(p_151522_)) {
-                list.add(p_151522_);
-            }
-
-            if (p_151522_ instanceof EnderDragon) {
-                for (EnderDragonPart enderdragonpart : ((EnderDragon)p_151522_).getSubEntities()) {
-                    if (p_151522_ != p_46536_ && p_46538_.test(enderdragonpart)) {
-                        list.add(enderdragonpart);
-                    }
-                }
-            }
-        });
-        return list;
+        // Paper start - rewrite chunk system
+        final List<Entity> ret = new java.util.ArrayList<>();
+
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(except, box, ret, predicate);
+
+        return ret;
+        // Paper end - rewrite chunk system
     }
 
     @Override
@@ -837,6 +_,8 @@
                 }
             }
 
+
+            if (false)
             if (p_261454_ instanceof EnderDragon enderdragon) {
                 for (EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
                     T t = p_261885_.tryCast(enderdragonpart);
@@ -851,6 +_,15 @@
 
             return AbortableIterationConsumer.Continuation.CONTINUE;
         });
+        for (net.neoforged.neoforge.entity.PartEntity<?> p : this.getPartEntities()) {
+            T t = p_261885_.tryCast(p);
+            if (t != null && t.getBoundingBox().intersects(p_262086_) && p_261688_.test(t)) {
+                p_262071_.add(t);
+                if (p_262071_.size() >= p_261858_) {
+                    break;
+                }
+            }
+        }
     }
 
     @Nullable
@@ -979,16 +_,15 @@
     public abstract Scoreboard getScoreboard();
 
     public void updateNeighbourForOutputSignal(BlockPos p_46718_, Block p_46719_) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for(Direction direction : Direction.values()) {
             BlockPos blockpos = p_46718_.relative(direction);
             if (this.hasChunkAt(blockpos)) {
                 BlockState blockstate = this.getBlockState(blockpos);
-                if (blockstate.is(Blocks.COMPARATOR)) {
-                    this.neighborChanged(blockstate, blockpos, p_46719_, p_46718_, false);
-                } else if (blockstate.isRedstoneConductor(this, blockpos)) {
+                blockstate.onNeighborChange(this, blockpos, p_46718_);
+                if (blockstate.isRedstoneConductor(this, blockpos)) {
                     blockpos = blockpos.relative(direction);
                     blockstate = this.getBlockState(blockpos);
-                    if (blockstate.is(Blocks.COMPARATOR)) {
+                    if (blockstate.getWeakChanges(this, blockpos)) {
                         this.neighborChanged(blockstate, blockpos, p_46719_, p_46718_, false);
                     }
                 }
@@ -1078,6 +_,18 @@
         return this.biomeManager;
     }
 
+    private double maxEntityRadius = 2.0D;
+    @Override
+    public double getMaxEntityRadius() {
+        return maxEntityRadius;
+    }
+    @Override
+    public double increaseMaxEntityRadius(double value) {
+        if (value > maxEntityRadius)
+            maxEntityRadius = value;
+        return maxEntityRadius;
+    }
+
     public final boolean isDebug() {
         return this.isDebug;
     }
@@ -1118,5 +_,38 @@
         public String getSerializedName() {
             return this.id;
         }
+    }
+
+    // Neo: Variable day time code
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public abstract void setDayTimeFraction(float dayTimeFraction);
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public abstract float getDayTimeFraction();
+
+    /**
+     * Returns the current ratio between game ticks and clock ticks. If this value is negative, no
+     * speed has been set and those two are coupled 1:1 (i.e. vanilla mode).
+     */
+    public abstract float getDayTimePerTick();
+
+    /**
+     * DO NOT CALL.
+     * <p>
+     * Use {@link net.minecraft.server.level.ServerLevel#setDayTimePerTick(float)} instead.
+     */
+    public abstract void setDayTimePerTick(float dayTimePerTick);
+
+    // advances the fractional daytime, returns the integer part of it
+    @org.jetbrains.annotations.ApiStatus.Internal
+    protected long advanceDaytime() {
+        if (getDayTimePerTick() < 0) {
+            return 1L; // avoid doing math (and rounding errors) if no speed has been set
+        }
+        float dayTimeStep = getDayTimeFraction() + getDayTimePerTick();
+        long result = (long)dayTimeStep;
+        setDayTimeFraction(dayTimeStep - result);
+        return result;
     }
 }
