--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -128,7 +_,7 @@
 import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
-public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, CommandSource, ScoreHolder {
+public abstract class Entity extends net.neoforged.neoforge.attachment.AttachmentHolder implements SyncedDataHolder, Nameable, EntityAccess, CommandSource, ScoreHolder, net.neoforged.neoforge.common.extensions.IEntityExtension , ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity { // Paper - rewrite chunk system // Paper - optimise entity tracker
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final String ID_TAG = "id";
     public static final String PASSENGERS_TAG = "Passengers";
@@ -149,6 +_,7 @@
     private static final double LAVA_SLOW_FLOW_SCALE = 0.0023333333333333335;
     public static final String UUID_TAG = "UUID";
     private static double viewScale = 1.0;
+    @Deprecated // Forge: Use the getter to allow overriding in mods
     private final EntityType<?> type;
     private int id = ENTITY_COUNTER.incrementAndGet();
     public boolean blocksBuilding;
@@ -193,9 +_,11 @@
     protected final RandomSource random = RandomSource.create();
     public int tickCount;
     private int remainingFireTicks = -this.getFireImmuneTicks();
-    protected boolean wasTouchingWater;
+    public boolean wasTouchingWater;
+    @Deprecated // Forge: Use forgeFluidTypeHeight instead
     protected Object2DoubleMap<TagKey<Fluid>> fluidHeight = new Object2DoubleArrayMap<>(2);
     protected boolean wasEyeInWater;
+    @Deprecated // Forge: Use forgeFluidTypeOnEyes instead
     private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
     public int invulnerableTime;
     protected boolean firstTick = true;
@@ -223,7 +_,7 @@
     public boolean hasImpulse;
     @Nullable
     public PortalProcessor portalProcess;
-    private int portalCooldown;
+    public int portalCooldown;
     private boolean invulnerable;
     protected UUID uuid = Mth.createInsecureUUID(this.random);
     protected String stringUUID = this.uuid.toString();
@@ -244,6 +_,112 @@
     @Nullable
     private BlockState inBlockState = null;
 
+    // Spigot start
+    public boolean collisionLoadChunks = false; // Paper
+    public boolean valid;
+    public final org.spigotmc.ActivationRange.ActivationType activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = Integer.MIN_VALUE;
+    public void inactiveTick() { }
+    // Spigot end
+    protected int numCollisions = 0; // Paper - Cap entity collisions
+    public boolean fromNetherPortal; // Paper - Add option to nerf pigmen from nether portals
+    public long activatedImmunityTick = Integer.MIN_VALUE; // Paper - EAR
+    public boolean isTemporarilyActive; // Paper - EAR
+    public boolean spawnedViaMobSpawner; // Paper - Yes this name is similar to above, upstream took the better one
+
+    // Paper start - rewrite chunk system
+    private final boolean isHardColliding = this.moonrise$isHardCollidingUncached();
+    private net.minecraft.server.level.FullChunkStatus chunkStatus;
+    private int sectionX = Integer.MIN_VALUE;
+    private int sectionY = Integer.MIN_VALUE;
+    private int sectionZ = Integer.MIN_VALUE;
+    private boolean updatingSectionStatus;
+
+    @Override
+    public final boolean moonrise$isHardColliding() {
+        return this.isHardColliding;
+    }
+
+    @Override
+    public final net.minecraft.server.level.FullChunkStatus moonrise$getChunkStatus() {
+        return this.chunkStatus;
+    }
+
+    @Override
+    public final void moonrise$setChunkStatus(final net.minecraft.server.level.FullChunkStatus status) {
+        this.chunkStatus = status;
+    }
+
+    @Override
+    public final int moonrise$getSectionX() {
+        return this.sectionX;
+    }
+
+    @Override
+    public final void moonrise$setSectionX(final int x) {
+        this.sectionX = x;
+    }
+
+    @Override
+    public final int moonrise$getSectionY() {
+        return this.sectionY;
+    }
+
+    @Override
+    public final void moonrise$setSectionY(final int y) {
+        this.sectionY = y;
+    }
+
+    @Override
+    public final int moonrise$getSectionZ() {
+        return this.sectionZ;
+    }
+
+    @Override
+    public final void moonrise$setSectionZ(final int z) {
+        this.sectionZ = z;
+    }
+
+    @Override
+    public final boolean moonrise$isUpdatingSectionStatus() {
+        return this.updatingSectionStatus;
+    }
+
+    @Override
+    public final void moonrise$setUpdatingSectionStatus(final boolean to) {
+        this.updatingSectionStatus = to;
+    }
+
+    @Override
+    public final boolean moonrise$hasAnyPlayerPassengers() {
+        if (this.passengers.isEmpty()) {
+            return false;
+        }
+        return this.getIndirectPassengersStream().anyMatch((entity) -> entity instanceof Player);
+    }
+    // Paper end - rewrite chunk system
+    // Paper start - optimise entity tracker
+    private net.minecraft.server.level.ChunkMap.TrackedEntity trackedEntity;
+
+    @Override
+    public final net.minecraft.server.level.ChunkMap.TrackedEntity moonrise$getTrackedEntity() {
+        return this.trackedEntity;
+    }
+
+    @Override
+    public final void moonrise$setTrackedEntity(final net.minecraft.server.level.ChunkMap.TrackedEntity trackedEntity) {
+        this.trackedEntity = trackedEntity;
+    }
+
+    private static void collectIndirectPassengers(final List<Entity> into, final List<Entity> from) {
+        for (final Entity passenger : from) {
+            into.add(passenger);
+            collectIndirectPassengers(into, ((Entity)(Object)passenger).passengers);
+        }
+    }
+    // Paper end - optimise entity tracker
+
     public Entity(EntityType<?> p_19870_, Level p_19871_) {
         this.type = p_19870_;
         this.level = p_19871_;
@@ -251,6 +_,13 @@
         this.position = Vec3.ZERO;
         this.blockPosition = BlockPos.ZERO;
         this.chunkPosition = ChunkPos.ZERO;
+        // Spigot start
+        if (p_19871_ != null) {
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, p_19871_.paperConfig());
+        } else {
+            this.defaultActivationState = false;
+        }
+        // Spigot end
         SynchedEntityData.Builder synchedentitydata$builder = new SynchedEntityData.Builder(this);
         synchedentitydata$builder.define(DATA_SHARED_FLAGS_ID, (byte)0);
         synchedentitydata$builder.define(DATA_AIR_SUPPLY_ID, this.getMaxAirSupply());
@@ -263,7 +_,10 @@
         this.defineSynchedData(synchedentitydata$builder);
         this.entityData = synchedentitydata$builder.build();
         this.setPos(0.0, 0.0, 0.0);
+        net.neoforged.neoforge.event.entity.EntityEvent.Size sizeEvent = net.neoforged.neoforge.event.EventHooks.getEntitySizeForge(this, Pose.STANDING, this.dimensions);
+        this.dimensions = sizeEvent.getNewSize();
         this.eyeHeight = this.dimensions.eyeHeight();
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.EntityEvent.EntityConstructing(this));
     }
 
     public boolean isColliding(BlockPos p_20040_, BlockState p_20041_) {
@@ -421,6 +_,7 @@
 
     public void baseTick() {
         this.level().getProfiler().push("entityBaseTick");
+        if (firstTick && this instanceof net.minecraft.world.entity.NeutralMob neutralMob) neutralMob.tickInitialPersistentAnger(level); // Paper - Prevent entity loading causing async lookups
         this.inBlockState = null;
         if (this.isPassenger() && this.getVehicle().isRemoved()) {
             this.stopRiding();
@@ -467,7 +_,7 @@
 
         if (this.isInLava()) {
             this.lavaHurt();
-            this.fallDistance *= 0.5F;
+            this.fallDistance *= this.getFluidFallDistanceModifier(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
         }
 
         this.checkBelowWorld();
@@ -598,12 +_,49 @@
         return this.onGround;
     }
 
+    // Paper start - detailed watchdog information
+    public final Object posLock = new Object(); // Paper - log detailed entity tick information
+
+    private Vec3 moveVector;
+    private double moveStartX;
+    private double moveStartY;
+    private double moveStartZ;
+
+    public final Vec3 getMoveVector() {
+        return this.moveVector;
+    }
+
+    public final double getMoveStartX() {
+        return this.moveStartX;
+    }
+
+    public final double getMoveStartY() {
+        return this.moveStartY;
+    }
+
+    public final double getMoveStartZ() {
+        return this.moveStartZ;
+    }
+    // Paper end - detailed watchdog information
+
     public void move(MoverType p_19973_, Vec3 p_19974_) {
+        // Paper start - detailed watchdog information
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        synchronized (this.posLock) {
+            this.moveStartX = this.getX();
+            this.moveStartY = this.getY();
+            this.moveStartZ = this.getZ();
+            this.moveVector = p_19974_;
+        }
+        try {
+            // Paper end - detailed watchdog information
         if (this.noPhysics) {
             this.setPos(this.getX() + p_19974_.x, this.getY() + p_19974_.y, this.getZ() + p_19974_.z);
         } else {
             this.wasOnFire = this.isOnFire();
             if (p_19973_ == MoverType.PISTON) {
+                this.activatedTick = Math.max(this.activatedTick, MinecraftServer.currentTick + 20); // Paper
+                this.activatedImmunityTick = Math.max(this.activatedImmunityTick, MinecraftServer.currentTick + 20);   // Paper
                 p_19974_ = this.limitPistonMovement(p_19974_);
                 if (p_19974_.equals(Vec3.ZERO)) {
                     return;
@@ -616,6 +_,13 @@
                 this.stuckSpeedMultiplier = Vec3.ZERO;
                 this.setDeltaMovement(Vec3.ZERO);
             }
+            // Paper start - ignore movement changes while inactive.
+            if (isTemporarilyActive && !(this instanceof ItemEntity) && p_19974_ == getDeltaMovement() && p_19973_ == MoverType.SELF) {
+                setDeltaMovement(Vec3.ZERO);
+                this.level.getProfiler().pop();
+                return;
+            }
+            // Paper end
 
             p_19974_ = this.maybeBackOffFromEdge(p_19974_, p_19973_);
             Vec3 vec3 = this.collide(p_19974_);
@@ -673,7 +_,7 @@
                     double d1 = vec3.x;
                     double d2 = vec3.y;
                     double d3 = vec3.z;
-                    this.flyDist = this.flyDist + (float)(vec3.length() * 0.6);
+                    this.flyDist = (float)((double)this.flyDist + vec3.length() * 0.6D);
                     BlockPos blockpos1 = this.getOnPos();
                     BlockState blockstate1 = this.level().getBlockState(blockpos1);
                     boolean flag1 = this.isStateClimbable(blockstate1);
@@ -717,18 +_,25 @@
                         this.setRemainingFireTicks(-this.getFireImmuneTicks());
                     }
 
-                    if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                    if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble() || this.isInFluidType((fluidType, height) -> this.canFluidExtinguish(fluidType)))) {
                         this.playEntityOnFireExtinguishedSound();
                     }
                 }
 
-                if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble() || this.isInFluidType((fluidType, height) -> this.canFluidExtinguish(fluidType)))) {
                     this.setRemainingFireTicks(-this.getFireImmuneTicks());
                 }
 
-                this.level().getProfiler().pop();
+                this.level.getProfiler().pop();
             }
         }
+        // Paper start - detailed watchdog information
+        } finally {
+            synchronized (this.posLock) { // Paper
+                this.moveVector = null;
+            } // Paper
+        }
+        // Paper end - detailed watchdog information
     }
 
     private boolean isStateClimbable(BlockState p_286733_) {
@@ -806,15 +_,13 @@
     }
 
     protected BlockPos getOnPos(float p_216987_) {
-        if (this.mainSupportingBlockPos.isPresent()) {
+        if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null) { // Paper - ensure no loads
             BlockPos blockpos = this.mainSupportingBlockPos.get();
             if (!(p_216987_ > 1.0E-5F)) {
                 return blockpos;
             } else {
                 BlockState blockstate = this.level().getBlockState(blockpos);
-                return (!((double)p_216987_ <= 0.5) || !blockstate.is(BlockTags.FENCES))
-                        && !blockstate.is(BlockTags.WALLS)
-                        && !(blockstate.getBlock() instanceof FenceGateBlock)
+                return (!((double)p_216987_ <= 0.5) || !blockstate.collisionExtendsVertically(this.level(), blockpos, this))
                     ? blockpos.atY(Mth.floor(this.position.y - (double)p_216987_))
                     : blockpos;
             }
@@ -879,35 +_,83 @@
         return p_20044_;
     }
 
-    private Vec3 collide(Vec3 p_20273_) {
-        AABB aabb = this.getBoundingBox();
-        List<VoxelShape> list = this.level().getEntityCollisions(this, aabb.expandTowards(p_20273_));
-        Vec3 vec3 = p_20273_.lengthSqr() == 0.0 ? p_20273_ : collideBoundingBox(this, p_20273_, aabb, this.level(), list);
-        boolean flag = p_20273_.x != vec3.x;
-        boolean flag1 = p_20273_.y != vec3.y;
-        boolean flag2 = p_20273_.z != vec3.z;
-        boolean flag3 = flag1 && p_20273_.y < 0.0;
-        if (this.maxUpStep() > 0.0F && (flag3 || this.onGround()) && (flag || flag2)) {
-            AABB aabb1 = flag3 ? aabb.move(0.0, vec3.y, 0.0) : aabb;
-            AABB aabb2 = aabb1.expandTowards(p_20273_.x, (double)this.maxUpStep(), p_20273_.z);
-            if (!flag3) {
-                aabb2 = aabb2.expandTowards(0.0, -1.0E-5F, 0.0);
-            }
-
-            List<VoxelShape> list1 = collectColliders(this, this.level, list, aabb2);
-            float f = (float)vec3.y;
-            float[] afloat = collectCandidateStepUpHeights(aabb1, list1, this.maxUpStep(), f);
-
-            for (float f1 : afloat) {
-                Vec3 vec31 = collideWithShapes(new Vec3(p_20273_.x, (double)f1, p_20273_.z), aabb1, list1);
-                if (vec31.horizontalDistanceSqr() > vec3.horizontalDistanceSqr()) {
-                    double d0 = aabb.minY - aabb1.minY;
-                    return vec31.add(0.0, -d0, 0.0);
-                }
-            }
-        }
-
-        return vec3;
+    private Vec3 collide(Vec3 movement) {
+        // Paper start - optimise collisions
+        final boolean xZero = movement.x == 0.0;
+        final boolean yZero = movement.y == 0.0;
+        final boolean zZero = movement.z == 0.0;
+        if (xZero & yZero & zZero) {
+            return movement;
+        }
+
+        final Level world = this.level;
+        final AABB currBoundingBox = this.getBoundingBox();
+
+        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isEmpty(currBoundingBox)) {
+            return movement;
+        }
+
+        final List<AABB> potentialCollisionsBB = new ArrayList<>();
+        final List<VoxelShape> potentialCollisionsVoxel = new ArrayList<>();
+        final double stepHeight = (double)this.maxUpStep();
+        final AABB collisionBox;
+        final boolean onGround = this.onGround;
+
+        if (xZero & zZero) {
+            if (movement.y > 0.0) {
+                collisionBox = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.cutUpwards(currBoundingBox, movement.y);
+            } else {
+                collisionBox = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.cutDownwards(currBoundingBox, movement.y);
+            }
+        } else {
+            // note: xZero == false or zZero == false
+            if (stepHeight > 0.0 && (onGround || (movement.y < 0.0))) {
+                // don't bother getting the collisions if we don't need them.
+                if (movement.y <= 0.0) {
+                    collisionBox = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.expandUpwards(currBoundingBox.expandTowards(movement.x, movement.y, movement.z), stepHeight);
+                } else {
+                    collisionBox = currBoundingBox.expandTowards(movement.x, Math.max(stepHeight, movement.y), movement.z);
+                }
+            } else {
+                collisionBox = currBoundingBox.expandTowards(movement.x, movement.y, movement.z);
+            }
+        }
+
+        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisions(
+                world, (Entity)(Object)this, collisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+                null, null
+        );
+
+        if (potentialCollisionsVoxel.isEmpty() && potentialCollisionsBB.isEmpty()) {
+            return movement;
+        }
+
+        final Vec3 limitedMoveVector = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
+
+        if (stepHeight > 0.0
+                && (onGround || (limitedMoveVector.y != movement.y && movement.y < 0.0))
+                && (limitedMoveVector.x != movement.x || limitedMoveVector.z != movement.z)) {
+            Vec3 vec3d2 = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(movement.x, stepHeight, movement.z), currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
+            final Vec3 vec3d3 = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(0.0, stepHeight, 0.0), currBoundingBox.expandTowards(movement.x, 0.0, movement.z), potentialCollisionsVoxel, potentialCollisionsBB);
+
+            if (vec3d3.y < stepHeight) {
+                final Vec3 vec3d4 = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(movement.x, 0.0D, movement.z), currBoundingBox.move(vec3d3), potentialCollisionsVoxel, potentialCollisionsBB).add(vec3d3);
+
+                if (vec3d4.horizontalDistanceSqr() > vec3d2.horizontalDistanceSqr()) {
+                    vec3d2 = vec3d4;
+                }
+            }
+
+            if (vec3d2.horizontalDistanceSqr() > limitedMoveVector.horizontalDistanceSqr()) {
+                return vec3d2.add(ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(0.0D, -vec3d2.y + movement.y, 0.0D), currBoundingBox.move(vec3d2), potentialCollisionsVoxel, potentialCollisionsBB));
+            }
+
+            return limitedMoveVector;
+        } else {
+            return limitedMoveVector;
+        }
+        // Paper end - optimise collisions
     }
 
     private static float[] collectCandidateStepUpHeights(AABB p_345729_, List<VoxelShape> p_345260_, float p_346165_, float p_345968_) {
@@ -1076,19 +_,19 @@
         return !blockstate.is(BlockTags.INSIDE_STEP_SOUND_BLOCKS) && !blockstate.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS) ? p_278049_ : blockpos;
     }
 
-    protected void playCombinationStepSounds(BlockState p_277472_, BlockState p_277630_) {
-        SoundType soundtype = p_277472_.getSoundType();
+    protected void playCombinationStepSounds(BlockState p_277472_, BlockState p_277630_, BlockPos primaryPos, BlockPos secondaryPos) {
+        SoundType soundtype = p_277472_.getSoundType(this.level, primaryPos, this);
         this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
-        this.playMuffledStepSound(p_277630_);
+        this.playMuffledStepSound(p_277630_, secondaryPos);
     }
 
-    protected void playMuffledStepSound(BlockState p_283110_) {
-        SoundType soundtype = p_283110_.getSoundType();
+    protected void playMuffledStepSound(BlockState p_283110_, BlockPos pos) {
+        SoundType soundtype = p_283110_.getSoundType(this.level, pos, this);
         this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.05F, soundtype.getPitch() * 0.8F);
     }
 
     protected void playStepSound(BlockPos p_20135_, BlockState p_20136_) {
-        SoundType soundtype = p_20136_.getSoundType();
+        SoundType soundtype = p_20136_.getSoundType(this.level, p_20135_, this);
         this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
     }
 
@@ -1241,20 +_,23 @@
 
     public void updateSwimming() {
         if (this.isSwimming()) {
-            this.setSwimming(this.isSprinting() && this.isInWater() && !this.isPassenger());
+            this.setSwimming(this.isSprinting() && (this.isInWater() || this.isInFluidType((fluidType, height) -> this.canSwimInFluidType(fluidType))) && !this.isPassenger());
         } else {
             this.setSwimming(
-                this.isSprinting() && this.isUnderWater() && !this.isPassenger() && this.level().getFluidState(this.blockPosition).is(FluidTags.WATER)
+                this.isSprinting() && (this.isUnderWater() || this.canStartSwimming()) && !this.isPassenger()
             );
         }
     }
 
     protected boolean updateInWaterStateAndDoFluidPushing() {
         this.fluidHeight.clear();
+        this.forgeFluidTypeHeight.clear();
         this.updateInWaterStateAndDoWaterCurrentPushing();
-        double d0 = this.level().dimensionType().ultraWarm() ? 0.007 : 0.0023333333333333335;
-        boolean flag = this.updateFluidHeightAndDoFluidPushing(FluidTags.LAVA, d0);
-        return this.isInWater() || flag;
+        if (this.isInFluidType() && !(this.getVehicle() instanceof Boat)) {
+            this.fallDistance *= this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().filter(e -> !e.getKey().isAir() && !e.getKey().isVanilla()).map(e -> this.getFluidFallDistanceModifier(e.getKey())).min(Float::compare).orElse(1F);
+            if (this.isInFluidType((fluidType, height) -> !fluidType.isAir() && !fluidType.isVanilla() && this.canFluidExtinguish(fluidType))) this.clearFire();
+        }
+        return this.isInFluidType();
     }
 
     void updateInWaterStateAndDoWaterCurrentPushing() {
@@ -1279,6 +_,7 @@
     private void updateFluidOnEyes() {
         this.wasEyeInWater = this.isEyeInFluid(FluidTags.WATER);
         this.fluidOnEyes.clear();
+        this.forgeFluidTypeOnEyes = net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE.value();
         double d0 = this.getEyeY();
         if (this.getVehicle() instanceof Boat boat && !boat.isUnderWater() && boat.getBoundingBox().maxY >= d0 && boat.getBoundingBox().minY <= d0) {
             return;
@@ -1288,7 +_,7 @@
         FluidState fluidstate = this.level().getFluidState(blockpos);
         double d1 = (double)((float)blockpos.getY() + fluidstate.getHeight(this.level(), blockpos));
         if (d1 > d0) {
-            fluidstate.getTags().forEach(this.fluidOnEyes::add);
+            this.forgeFluidTypeOnEyes = fluidstate.getFluidType();
         }
     }
 
@@ -1333,12 +_,13 @@
     }
 
     public boolean canSpawnSprintParticle() {
-        return this.isSprinting() && !this.isInWater() && !this.isSpectator() && !this.isCrouching() && !this.isInLava() && this.isAlive();
+        return this.isSprinting() && !this.isInWater() && !this.isSpectator() && !this.isCrouching() && !this.isInLava() && this.isAlive() && !this.isInFluidType();
     }
 
     protected void spawnSprintParticle() {
         BlockPos blockpos = this.getOnPosLegacy();
         BlockState blockstate = this.level().getBlockState(blockpos);
+        if(!blockstate.addRunningEffects(level, blockpos, this))
         if (blockstate.getRenderShape() != RenderShape.INVISIBLE) {
             Vec3 vec3 = this.getDeltaMovement();
             BlockPos blockpos1 = this.blockPosition();
@@ -1352,16 +_,19 @@
                 d1 = Mth.clamp(d1, (double)blockpos.getZ(), (double)blockpos.getZ() + 1.0);
             }
 
-            this.level().addParticle(new BlockParticleOption(ParticleTypes.BLOCK, blockstate), d0, this.getY() + 0.1, d1, vec3.x * -4.0, 1.5, vec3.z * -4.0);
+            this.level().addParticle(new BlockParticleOption(ParticleTypes.BLOCK, blockstate).setPos(blockpos), d0, this.getY() + 0.1, d1, vec3.x * -4.0, 1.5, vec3.z * -4.0);
         }
     }
 
+    @Deprecated // Forge: Use isEyeInFluidType instead
     public boolean isEyeInFluid(TagKey<Fluid> p_204030_) {
+        if (p_204030_ == FluidTags.WATER) return this.isEyeInFluidType(net.neoforged.neoforge.common.NeoForgeMod.WATER_TYPE.value());
+        else if (p_204030_ == FluidTags.LAVA) return this.isEyeInFluidType(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
         return this.fluidOnEyes.contains(p_204030_);
     }
 
     public boolean isInLava() {
-        return !this.firstTick && this.fluidHeight.getDouble(FluidTags.LAVA) > 0.0;
+        return !this.firstTick && this.forgeFluidTypeHeight.getDouble(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value()) > 0.0D;
     }
 
     public void moveRelative(float p_19921_, Vec3 p_19922_) {
@@ -1478,6 +_,7 @@
     public void push(Entity p_20293_) {
         if (!this.isPassengerOfSameVehicle(p_20293_)) {
             if (!p_20293_.noPhysics && !this.noPhysics) {
+                if (this.level.paperConfig().collisions.onlyPlayersCollide && !(p_20293_ instanceof ServerPlayer || this instanceof ServerPlayer)) return; // Paper - Collision option for requiring a player participant
                 double d0 = p_20293_.getX() - this.getX();
                 double d1 = p_20293_.getZ() - this.getZ();
                 double d2 = Mth.absMax(d0, d1);
@@ -1704,6 +_,10 @@
                 p_20241_.put("Tags", listtag);
             }
 
+            CompoundTag attachments = serializeAttachments(registryAccess());
+            if (attachments != null) p_20241_.put(ATTACHMENTS_NBT_KEY, attachments);
+            if (persistentData != null) p_20241_.put("NeoForgeData", persistentData.copy());
+
             this.addAdditionalSaveData(p_20241_);
             if (this.isVehicle()) {
                 ListTag listtag1 = new ListTag();
@@ -1784,6 +_,8 @@
                 this.setGlowingTag(p_20259_.getBoolean("Glowing"));
                 this.setTicksFrozen(p_20259_.getInt("TicksFrozen"));
                 this.hasVisualFire = p_20259_.getBoolean("HasVisualFire");
+                if (p_20259_.contains("NeoForgeData", 10)) persistentData = p_20259_.getCompound("NeoForgeData");
+                if (p_20259_.contains(ATTACHMENTS_NBT_KEY, net.minecraft.nbt.Tag.TAG_COMPOUND)) deserializeAttachments(registryAccess(), p_20259_.getCompound(ATTACHMENTS_NBT_KEY));
                 if (p_20259_.contains("Tags", 9)) {
                     this.tags.clear();
                     ListTag listtag3 = p_20259_.getList("Tags", 8);
@@ -1868,6 +_,8 @@
         } else {
             ItemEntity itementity = new ItemEntity(this.level(), this.getX(), this.getY() + (double)p_19986_, this.getZ(), p_19985_);
             itementity.setDefaultPickUpDelay();
+            if (captureDrops() != null) captureDrops().add(itementity);
+            else
             this.level().addFreshEntity(itementity);
             return itementity;
         }
@@ -1878,26 +_,75 @@
     }
 
     public boolean isInWall() {
+        // Paper start - optimise collisions
         if (this.noPhysics) {
             return false;
-        } else {
-            float f = this.dimensions.width() * 0.8F;
-            AABB aabb = AABB.ofSize(this.getEyePosition(), (double)f, 1.0E-6, (double)f);
-            return BlockPos.betweenClosedStream(aabb)
-                .anyMatch(
-                    p_201942_ -> {
-                        BlockState blockstate = this.level().getBlockState(p_201942_);
-                        return !blockstate.isAir()
-                            && blockstate.isSuffocating(this.level(), p_201942_)
-                            && Shapes.joinIsNotEmpty(
-                                blockstate.getCollisionShape(this.level(), p_201942_)
-                                    .move((double)p_201942_.getX(), (double)p_201942_.getY(), (double)p_201942_.getZ()),
-                                Shapes.create(aabb),
-                                BooleanOp.AND
-                            );
-                    }
-                );
-        }
+        }
+
+        final float reducedWith = this.dimensions.width() * 0.8F;
+        final AABB box = AABB.ofSize(this.getEyePosition(), reducedWith, 1.0E-6D, reducedWith);
+
+        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isEmpty(box)) {
+            return false;
+        }
+
+        final BlockPos.MutableBlockPos tempPos = new BlockPos.MutableBlockPos();
+
+        final int minX = Mth.floor(box.minX);
+        final int minY = Mth.floor(box.minY);
+        final int minZ = Mth.floor(box.minZ);
+        final int maxX = Mth.floor(box.maxX);
+        final int maxY = Mth.floor(box.maxY);
+        final int maxZ = Mth.floor(box.maxZ);
+
+        final net.minecraft.world.level.chunk.ChunkSource chunkProvider = this.level.getChunkSource();
+
+        long lastChunkKey = ChunkPos.INVALID_CHUNK_POS;
+        net.minecraft.world.level.chunk.LevelChunk lastChunk = null;
+        for (int fz = minZ; fz <= maxZ; ++fz) {
+            tempPos.setZ(fz);
+            for (int fx = minX; fx <= maxX; ++fx) {
+                final int newChunkX = fx >> 4;
+                final int newChunkZ = fz >> 4;
+                final net.minecraft.world.level.chunk.LevelChunk chunk = lastChunkKey == (lastChunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(newChunkX, newChunkZ)) ?
+                        lastChunk : (lastChunk = (net.minecraft.world.level.chunk.LevelChunk)chunkProvider.getChunk(newChunkX, newChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, true));
+                tempPos.setX(fx);
+                for (int fy = minY; fy <= maxY; ++fy) {
+                    tempPos.setY(fy);
+
+                    final BlockState state = chunk.getBlockState(tempPos);
+
+                    if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)state).moonrise$emptyCollisionShape() || !state.isSuffocating(this.level, tempPos)) {
+                        continue;
+                    }
+
+                    // Yes, it does not use the Entity context stuff.
+                    final VoxelShape collisionShape = state.getCollisionShape(this.level, tempPos);
+
+                    if (collisionShape.isEmpty()) {
+                        continue;
+                    }
+
+                    final AABB toCollide = box.move(-(double)fx, -(double)fy, -(double)fz);
+
+                    final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)collisionShape).moonrise$getSingleAABBRepresentation();
+                    if (singleAABB != null) {
+                        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersect(singleAABB, toCollide)) {
+                            return true;
+                        }
+                        continue;
+                    }
+
+                    if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersectNoEmpty(collisionShape, toCollide)) {
+                        return true;
+                    }
+                    continue;
+                }
+            }
+        }
+
+        return false;
+        // Paper end - optimise collisions
     }
 
     public InteractionResult interact(Player p_19978_, InteractionHand p_19979_) {
@@ -1935,7 +_,11 @@
 
     public void rideTick() {
         this.setDeltaMovement(Vec3.ZERO);
-        this.tick();
+        // Neo: Permit cancellation of Entity#tick via EntityTickEvent.Pre
+        if (!net.neoforged.neoforge.event.EventHooks.fireEntityTickPre(this).isCanceled()) {
+            this.tick();
+            net.neoforged.neoforge.event.EventHooks.fireEntityTickPost(this);
+        }
         if (this.isPassenger()) {
             this.getVehicle().positionRider(this);
         }
@@ -1993,6 +_,7 @@
                 }
             }
 
+        if (!net.neoforged.neoforge.event.EventHooks.canMountEntity(this, p_19966_, true)) return false;
             if (p_19967_ || this.canRide(p_19966_) && p_19966_.canAddPassenger(this)) {
                 if (this.isPassenger()) {
                     this.stopRiding();
@@ -2024,6 +_,7 @@
     public void removeVehicle() {
         if (this.vehicle != null) {
             Entity entity = this.vehicle;
+            if (!net.neoforged.neoforge.event.EventHooks.canMountEntity(this, entity, false)) return;
             this.vehicle = null;
             entity.removePassenger(this);
         }
@@ -2073,6 +_,8 @@
         return this.passengers.isEmpty();
     }
 
+    /** @deprecated Forge: Use {@link #canBeRiddenUnderFluidType(net.neoforged.neoforge.fluids.FluidType, Entity) rider sensitive version} */
+    @Deprecated
     protected boolean couldAcceptPassenger() {
         return true;
     }
@@ -2257,7 +_,7 @@
     }
 
     public boolean isVisuallyCrawling() {
-        return this.isVisuallySwimming() && !this.isInWater();
+        return this.isVisuallySwimming() && !this.isInWater() && !this.isInFluidType((fluidType, height) -> this.canSwimInFluidType(fluidType));
     }
 
     public void setSwimming(boolean p_20283_) {
@@ -2366,7 +_,7 @@
             this.igniteForSeconds(8.0F);
         }
 
-        this.hurt(this.damageSources().lightningBolt(), 5.0F);
+        this.hurt(this.damageSources().lightningBolt(), p_19928_.getDamage());
     }
 
     public void onAboveBubbleCol(boolean p_20313_) {
@@ -2461,7 +_,7 @@
     }
 
     protected Component getTypeName() {
-        return this.type.getDescription();
+        return this.getType().getDescription(); // Forge: Use getter to allow overriding by mods
     }
 
     public boolean is(Entity p_20356_) {
@@ -2516,10 +_,11 @@
     }
 
     public boolean isInvulnerableTo(DamageSource p_20122_) {
-        return this.isRemoved()
+        boolean isVanillaInvulnerable = this.isRemoved()
             || this.invulnerable && !p_20122_.is(DamageTypeTags.BYPASSES_INVULNERABILITY) && !p_20122_.isCreativePlayer()
             || p_20122_.is(DamageTypeTags.IS_FIRE) && this.fireImmune()
             || p_20122_.is(DamageTypeTags.IS_FALL) && this.getType().is(EntityTypeTags.FALL_DAMAGE_IMMUNE);
+        return net.neoforged.neoforge.common.CommonHooks.isEntityInvulnerableTo(this, p_20122_, isVanillaInvulnerable);
     }
 
     public boolean isInvulnerable() {
@@ -2544,6 +_,7 @@
 
     @Nullable
     public Entity changeDimension(DimensionTransition p_350951_) {
+        if (!net.neoforged.neoforge.common.CommonHooks.onTravelToDimension(this, p_350951_.newLevel().dimension())) return null;
         if (this.level() instanceof ServerLevel serverlevel && !this.isRemoved()) {
             ServerLevel serverlevel1 = p_350951_.newLevel();
             List<Entity> list = this.getPassengers();
@@ -2667,6 +_,7 @@
         return this.stringUUID;
     }
 
+    @Deprecated // Forge: Use FluidType sensitive version
     public boolean isPushedByFluid() {
         return true;
     }
@@ -2783,6 +_,8 @@
         EntityDimensions entitydimensions = this.dimensions;
         Pose pose = this.getPose();
         EntityDimensions entitydimensions1 = this.getDimensions(pose);
+        net.neoforged.neoforge.event.entity.EntityEvent.Size sizeEvent = net.neoforged.neoforge.event.EventHooks.getEntitySizeForge(this, pose, entitydimensions, entitydimensions1);
+        entitydimensions1 = sizeEvent.getNewSize();
         this.dimensions = entitydimensions1;
         this.eyeHeight = entitydimensions1.eyeHeight();
         this.reapplyPosition();
@@ -2966,21 +_,34 @@
     }
 
     private Stream<Entity> getIndirectPassengersStream() {
+        if (this.passengers.isEmpty()) { return Stream.of(); } // Paper - Optimize indirect passenger iteration
         return this.passengers.stream().flatMap(Entity::getSelfAndPassengers);
     }
 
     @Override
     public Stream<Entity> getSelfAndPassengers() {
+        if (this.passengers.isEmpty()) { return Stream.of(this); } // Paper - Optimize indirect passenger iteration
         return Stream.concat(Stream.of(this), this.getIndirectPassengersStream());
     }
 
     @Override
     public Stream<Entity> getPassengersAndSelf() {
+        if (this.passengers.isEmpty()) { return Stream.of(this); } // Paper - Optimize indirect passenger iteration
         return Stream.concat(this.passengers.stream().flatMap(Entity::getPassengersAndSelf), Stream.of(this));
     }
 
     public Iterable<Entity> getIndirectPassengers() {
-        return () -> this.getIndirectPassengersStream().iterator();
+        // Paper start - optimise entity tracker
+        final List<Entity> ret = new ArrayList<>();
+
+        if (this.passengers.isEmpty()) {
+            return ret;
+        }
+
+        collectIndirectPassengers(ret, this.passengers);
+
+        return ret;
+        // Paper end - optimise entity tracker
     }
 
     public int countPlayerPassengers() {
@@ -2988,6 +_,7 @@
     }
 
     public boolean hasExactlyOnePlayerPassenger() {
+        if (this.passengers.isEmpty()) { return false; } // Paper - Optimize indirect passenger iteration
         return this.countPlayerPassengers() == 1;
     }
 
@@ -3110,9 +_,17 @@
         return Mth.lerp(p_352259_, this.yRotO, this.yRot);
     }
 
+    @Deprecated // Forge: Use no parameter version instead, only for vanilla Tags
     public boolean updateFluidHeightAndDoFluidPushing(TagKey<Fluid> p_204032_, double p_204033_) {
+        this.updateFluidHeightAndDoFluidPushing();
+        if(p_204032_ == FluidTags.WATER) return this.isInFluidType(net.neoforged.neoforge.common.NeoForgeMod.WATER_TYPE.value());
+        else if (p_204032_ == FluidTags.LAVA) return this.isInFluidType(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
+        else return false;
+    }
+
+    public void updateFluidHeightAndDoFluidPushing() {
         if (this.touchingUnloadedChunk()) {
-            return false;
+            return;
         } else {
             AABB aabb = this.getBoundingBox().deflate(0.001);
             int i = Mth.floor(aabb.minX);
@@ -3127,25 +_,36 @@
             Vec3 vec3 = Vec3.ZERO;
             int k1 = 0;
             BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
+            class InterimCalculation {
+                double fluidHeight = 0.0D;
+                Vec3 flowVector = Vec3.ZERO;
+                int blockCount = 0;
+            }
+            it.unimi.dsi.fastutil.objects.Object2ObjectMap<net.neoforged.neoforge.fluids.FluidType, InterimCalculation> interimCalcs = null;
 
             for (int l1 = i; l1 < j; l1++) {
                 for (int i2 = k; i2 < l; i2++) {
                     for (int j2 = i1; j2 < j1; j2++) {
                         blockpos$mutableblockpos.set(l1, i2, j2);
                         FluidState fluidstate = this.level().getFluidState(blockpos$mutableblockpos);
-                        if (fluidstate.is(p_204032_)) {
+                        net.neoforged.neoforge.fluids.FluidType fluidType = fluidstate.getFluidType();
+                        if (!fluidType.isAir()) {
                             double d1 = (double)((float)i2 + fluidstate.getHeight(this.level(), blockpos$mutableblockpos));
                             if (d1 >= aabb.minY) {
                                 flag1 = true;
-                                d0 = Math.max(d1 - aabb.minY, d0);
-                                if (flag) {
+                                if (interimCalcs == null) {
+                                    interimCalcs = new it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap<>();
+                                }
+                                InterimCalculation interim = interimCalcs.computeIfAbsent(fluidType, t -> new InterimCalculation());
+                                interim.fluidHeight = Math.max(d1 - aabb.minY, interim.fluidHeight);
+                                if (this.isPushedByFluid(fluidType)) {
                                     Vec3 vec31 = fluidstate.getFlow(this.level(), blockpos$mutableblockpos);
-                                    if (d0 < 0.4) {
-                                        vec31 = vec31.scale(d0);
+                                    if (interim.fluidHeight < 0.4D) {
+                                        vec31 = vec31.scale(interim.fluidHeight);
                                     }
 
-                                    vec3 = vec3.add(vec31);
-                                    k1++;
+                                    interim.flowVector = interim.flowVector.add(vec31);
+                                    interim.blockCount++;
                                 }
                             }
                         }
@@ -3153,27 +_,30 @@
                 }
             }
 
-            if (vec3.length() > 0.0) {
-                if (k1 > 0) {
-                    vec3 = vec3.scale(1.0 / (double)k1);
+            if(interimCalcs != null) {
+            interimCalcs.forEach((fluidType, interim) -> {
+            if (interim.flowVector.length() > 0.0D) {
+                if (interim.blockCount > 0) {
+                    interim.flowVector = interim.flowVector.scale(1.0D / (double)interim.blockCount);
                 }
 
                 if (!(this instanceof Player)) {
-                    vec3 = vec3.normalize();
+                    interim.flowVector = interim.flowVector.normalize();
                 }
 
                 Vec3 vec32 = this.getDeltaMovement();
-                vec3 = vec3.scale(p_204033_);
+                interim.flowVector = interim.flowVector.scale(this.getFluidMotionScale(fluidType));
                 double d2 = 0.003;
-                if (Math.abs(vec32.x) < 0.003 && Math.abs(vec32.z) < 0.003 && vec3.length() < 0.0045000000000000005) {
-                    vec3 = vec3.normalize().scale(0.0045000000000000005);
+                if (Math.abs(vec32.x) < 0.003D && Math.abs(vec32.z) < 0.003D && interim.flowVector.length() < 0.0045000000000000005D) {
+                    interim.flowVector = interim.flowVector.normalize().scale(0.0045000000000000005D);
                 }
 
-                this.setDeltaMovement(this.getDeltaMovement().add(vec3));
+                this.setDeltaMovement(this.getDeltaMovement().add(interim.flowVector));
             }
 
-            this.fluidHeight.put(p_204032_, d0);
-            return flag1;
+            this.setFluidTypeHeight(fluidType, interim.fluidHeight);
+            });
+            }
         }
     }
 
@@ -3186,7 +_,10 @@
         return !this.level().hasChunksAt(i, k, j, l);
     }
 
+    @Deprecated // Forge: Use getFluidTypeHeight instead
     public double getFluidHeight(TagKey<Fluid> p_204037_) {
+        if (p_204037_ == FluidTags.WATER) return getFluidTypeHeight(net.neoforged.neoforge.common.NeoForgeMod.WATER_TYPE.value());
+        else if (p_204037_ == FluidTags.LAVA) return getFluidTypeHeight(net.neoforged.neoforge.common.NeoForgeMod.LAVA_TYPE.value());
         return this.fluidHeight.getDouble(p_204037_);
     }
 
@@ -3244,7 +_,9 @@
     }
 
     public void setDeltaMovement(Vec3 p_20257_) {
-        this.deltaMovement = p_20257_;
+        synchronized (this.posLock) { // Paper
+            this.deltaMovement = p_20257_;
+        }
     }
 
     public void addDeltaMovement(Vec3 p_250128_) {
@@ -3308,8 +_,19 @@
     }
 
     public final void setPosRaw(double p_20344_, double p_20345_, double p_20346_) {
+        // Paper start - rewrite chunk system
+        if (this.updatingSectionStatus) {
+            LOGGER.error(
+                    "Refusing to update position for entity " + this + " to position " + new Vec3(p_20344_, p_20345_, p_20346_)
+                            + " since it is processing a section status update", new Throwable()
+            );
+            return;
+        }
+        // Paper end - rewrite chunk system
         if (this.position.x != p_20344_ || this.position.y != p_20345_ || this.position.z != p_20346_) {
-            this.position = new Vec3(p_20344_, p_20345_, p_20346_);
+            synchronized (this.posLock) { // Paper
+                this.position = new Vec3(p_20344_, p_20345_, p_20346_);
+            }
             int i = Mth.floor(p_20344_);
             int j = Mth.floor(p_20345_);
             int k = Mth.floor(p_20346_);
@@ -3323,6 +_,7 @@
 
             this.levelCallback.onMove();
         }
+        if (this.isAddedToLevel() && !this.level.isClientSide && !this.isRemoved()) this.level.getChunk((int) Math.floor(p_20344_) >> 4, (int) Math.floor(p_20346_) >> 4); // Forge - ensure target chunk is loaded.
     }
 
     public void checkDespawn() {
@@ -3412,6 +_,12 @@
 
     @Override
     public final void setRemoved(Entity.RemovalReason p_146876_) {
+        // Paper start - rewrite chunk system
+        if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
+            LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
+            return;
+        }
+        // Paper end - rewrite chunk system
         if (this.removalReason == null) {
             this.removalReason = p_146876_;
         }
@@ -3420,7 +_,7 @@
             this.stopRiding();
         }
 
-        this.getPassengers().forEach(Entity::stopRiding);
+        if (this.removalReason != Entity.RemovalReason.UNLOADED_TO_CHUNK) this.getPassengers().forEach(Entity::stopRiding); // Paper - rewrite chunk system
         this.levelCallback.onRemove(p_146876_);
     }
 
@@ -3449,6 +_,128 @@
 
     public boolean mayInteract(Level p_146843_, BlockPos p_146844_) {
         return true;
+    }
+
+    /**
+     * Neo: Short-lived holder of dropped item entities. Used mainly for Neo hooks and event logic.
+     * <p>
+     * When not null, records all item entities from {@link #spawnAtLocation(ItemStack, float)} and {@link net.minecraft.server.level.ServerPlayer#drop(ItemStack, boolean, boolean)} instead of adding them to the world.
+     */
+    @Nullable
+    private java.util.Collection<ItemEntity> captureDrops = null;
+
+    @Nullable
+    @Override
+    public java.util.Collection<ItemEntity> captureDrops() {
+        return captureDrops;
+    }
+
+    @Nullable
+    @Override
+    public java.util.Collection<ItemEntity> captureDrops(@Nullable java.util.Collection<ItemEntity> value) {
+        java.util.Collection<ItemEntity> ret = captureDrops;
+        this.captureDrops = value;
+        return ret;
+    }
+
+    // Neo: Injected ability to store arbitrary nbt onto entities in ways that allow inter-mod compat without compile-time dependencies
+    private CompoundTag persistentData;
+
+    @Override
+    public CompoundTag getPersistentData() {
+        if (persistentData == null)
+            persistentData = new CompoundTag();
+        return persistentData;
+    }
+
+    // Neo: Set the default behavior for trampling on Farmland
+    @Override
+    public boolean canTrample(BlockState state, BlockPos pos, float fallDistance) {
+        return level.random.nextFloat() < fallDistance - 0.5F
+             && this instanceof LivingEntity
+             && (this instanceof Player || net.neoforged.neoforge.event.EventHooks.canEntityGrief(level, this))
+             && this.getBbWidth() * this.getBbWidth() * this.getBbHeight() > 0.512F;
+    }
+
+    /**
+     * Neo: Internal use for keeping track of entities that are tracked by a world, to
+     * allow guarantees that entity position changes will force a chunk load, avoiding
+     * potential issues with entity desyncing and bad chunk data.
+     */
+    private boolean isAddedToLevel;
+
+    @Override
+    public final boolean isAddedToLevel() { return this.isAddedToLevel; }
+
+    @Override
+    public void onAddedToLevel() { this.isAddedToLevel = true; }
+
+    @Override
+    public void onRemovedFromLevel() { this.isAddedToLevel = false; }
+
+    // Neo: Helper method to stop an entity from being removed if already marked for removal
+    @Override
+    public void revive() {
+        this.unsetRemoved();
+    }
+
+    // Neo: New logic for determining entity-fluid interactions. Replaces the vanilla logic that used fluids/fluid tags.
+    protected Object2DoubleMap<net.neoforged.neoforge.fluids.FluidType> forgeFluidTypeHeight = new Object2DoubleArrayMap<>(net.neoforged.neoforge.fluids.FluidType.SIZE.get());
+    private net.neoforged.neoforge.fluids.FluidType forgeFluidTypeOnEyes = net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE.value();
+
+    protected final void setFluidTypeHeight(net.neoforged.neoforge.fluids.FluidType type, double height) {
+        this.forgeFluidTypeHeight.put(type, height);
+    }
+
+    @Override
+    public final double getFluidTypeHeight(net.neoforged.neoforge.fluids.FluidType type) {
+        return this.forgeFluidTypeHeight.getDouble(type);
+    }
+
+    @Override
+    public final boolean isInFluidType(java.util.function.BiPredicate<net.neoforged.neoforge.fluids.FluidType, Double> predicate, boolean forAllTypes) {
+        if (this.forgeFluidTypeHeight.isEmpty()) {
+            return false;
+        }
+        return forAllTypes ? this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().allMatch(e -> predicate.test(e.getKey(), e.getDoubleValue()))
+                  : this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().anyMatch(e -> predicate.test(e.getKey(), e.getDoubleValue()));
+    }
+
+    @Override
+    public final boolean isInFluidType() {
+        return this.forgeFluidTypeHeight.size() > 0;
+    }
+
+    @Override
+    public final net.neoforged.neoforge.fluids.FluidType getEyeInFluidType() {
+        return forgeFluidTypeOnEyes;
+    }
+
+    @Override
+    public net.neoforged.neoforge.fluids.FluidType getMaxHeightFluidType() {
+        if (this.forgeFluidTypeHeight.isEmpty()) {
+            return net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE.value();
+        }
+        return this.forgeFluidTypeHeight.object2DoubleEntrySet().stream().max(java.util.Comparator.comparingDouble(Object2DoubleMap.Entry::getDoubleValue)).map(Object2DoubleMap.Entry::getKey).orElseGet(net.neoforged.neoforge.common.NeoForgeMod.EMPTY_TYPE::value);
+    }
+
+    // Neo: Hookup Attachment data setting
+    @Override
+    @Nullable
+    public final <T> T setData(net.neoforged.neoforge.attachment.AttachmentType<T> type, T data) {
+        // Entities are always saved, no setChanged() call is necessary.
+        return super.setData(type, data);
+    }
+
+    // Neo: Hookup Capabilities getters to entities
+    @Nullable
+    public final <T, C extends @org.jetbrains.annotations.Nullable Object> T getCapability(net.neoforged.neoforge.capabilities.EntityCapability<T, C> capability, C context) {
+        return capability.getCapability(this, context);
+    }
+
+    @Nullable
+    public final <T> T getCapability(net.neoforged.neoforge.capabilities.EntityCapability<T, @org.jetbrains.annotations.Nullable Void> capability) {
+        return capability.getCapability(this, null);
     }
 
     public Level level() {
