--- a/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -18,7 +_,7 @@
 import net.minecraft.nbt.ListTag;
 import net.minecraft.world.level.ChunkPos;
 
-public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickContainerAccess<T> {
+public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickContainerAccess<T>, ca.spottedleaf.moonrise.patches.chunk_system.ticks.ChunkSystemLevelChunkTicks { // Paper - rewrite chunk system
     private final Queue<ScheduledTick<T>> tickQueue = new PriorityQueue<>(ScheduledTick.DRAIN_ORDER);
     @Nullable
     private List<SavedTick<T>> pendingTicks;
@@ -26,6 +_,30 @@
     @Nullable
     private BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> onTickAdded;
 
+    // Paper start - rewrite chunk system
+    /*
+     * Since ticks are saved using relative delays, we need to consider the entire tick list dirty when there are scheduled ticks
+     * and the last saved tick is not equal to the current tick
+     */
+    /*
+     * In general, it would be nice to be able to "re-pack" ticks once the chunk becomes non-ticking again, but that is a
+     * bit out of scope for the chunk system
+     */
+
+    private boolean dirty;
+    private long lastSaved = Long.MIN_VALUE;
+
+    @Override
+    public final boolean moonrise$isDirty(final long tick) {
+        return this.dirty || (!this.tickQueue.isEmpty() && tick != this.lastSaved);
+    }
+
+    @Override
+    public final void moonrise$clearDirty() {
+        this.dirty = false;
+    }
+    // Paper end - rewrite chunk system
+
     public LevelChunkTicks() {
     }
 
@@ -50,7 +_,7 @@
     public ScheduledTick<T> poll() {
         ScheduledTick<T> scheduledtick = this.tickQueue.poll();
         if (scheduledtick != null) {
-            this.ticksPerPosition.remove(scheduledtick);
+            this.ticksPerPosition.remove(scheduledtick); this.dirty = true; // Paper - rewrite chunk system
         }
 
         return scheduledtick;
@@ -59,7 +_,7 @@
     @Override
     public void schedule(ScheduledTick<T> p_193177_) {
         if (this.ticksPerPosition.add(p_193177_)) {
-            this.scheduleUnchecked(p_193177_);
+            this.scheduleUnchecked(p_193177_); this.dirty = true; // Paper - rewrite chunk system
         }
     }
 
@@ -81,7 +_,7 @@
         while (iterator.hasNext()) {
             ScheduledTick<T> scheduledtick = iterator.next();
             if (p_193184_.test(scheduledtick)) {
-                iterator.remove();
+                iterator.remove(); this.dirty = true; // Paper - rewrite chunk system
                 this.ticksPerPosition.remove(scheduledtick);
             }
         }
@@ -98,6 +_,7 @@
 
     public ListTag save(long p_193174_, Function<T, String> p_193175_) {
         ListTag listtag = new ListTag();
+        this.lastSaved = p_193174_; // Paper - rewrite chunk system
         if (this.pendingTicks != null) {
             for (SavedTick<T> savedtick : this.pendingTicks) {
                 listtag.add(savedtick.save(p_193175_));
@@ -113,6 +_,7 @@
 
     public void unpack(long p_193172_) {
         if (this.pendingTicks != null) {
+            this.lastSaved = p_193172_; // Paper - rewrite chunk system
             int i = -this.pendingTicks.size();
 
             for (SavedTick<T> savedtick : this.pendingTicks) {
