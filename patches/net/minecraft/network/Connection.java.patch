--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -86,9 +_,9 @@
     private static final ProtocolInfo<ServerHandshakePacketListener> INITIAL_PROTOCOL = HandshakeProtocols.SERVERBOUND;
     private final PacketFlow receiving;
     private volatile boolean sendLoginDisconnect = true;
-    private final Queue<Consumer<Connection>> pendingActions = Queues.newConcurrentLinkedQueue();
+    private final Queue<WrappedConsumer> pendingActions = Queues.newConcurrentLinkedQueue(); // Paper
     private Channel channel;
-    private SocketAddress address;
+    public SocketAddress address;
     @Nullable
     private volatile PacketListener disconnectListener;
     @Nullable
@@ -107,6 +_,23 @@
     private volatile DisconnectionDetails delayedDisconnect;
     @Nullable
     BandwidthDebugMonitor bandwidthDebugMonitor;
+    @Nullable
+    private ProtocolInfo<?> inboundProtocol;
+
+    // Paper start - Optimize network
+    private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush"); // Paper - Disable explicit network manager flushing
+    public boolean isPending = true;
+    public boolean queueImmunity;
+    // Paper end - Optimize network
+    // Paper start - add utility methods
+    public final net.minecraft.server.level.ServerPlayer getPlayer() {
+        if (this.packetListener instanceof net.minecraft.server.network.ServerGamePacketListenerImpl impl) {
+            return impl.player;
+        } else {
+            return null;
+        }
+    }
+    // Paper end - add utility methods
 
     public Connection(PacketFlow p_129482_) {
         this.receiving = p_129482_;
@@ -120,11 +_,13 @@
         if (this.delayedDisconnect != null) {
             this.disconnect(this.delayedDisconnect);
         }
+        net.neoforged.neoforge.network.connection.ConnectionUtils.setConnection(p_129525_, this);
     }
 
     @Override
     public void channelInactive(ChannelHandlerContext p_129527_) {
         this.disconnect(Component.translatable("disconnect.endOfStream"));
+        net.neoforged.neoforge.network.connection.ConnectionUtils.removeConnection(p_129527_);
     }
 
     @Override
@@ -141,6 +_,13 @@
                 } else {
                     Component component = Component.translatable("disconnect.genericReason", "Internal Exception: " + p_129534_);
                     PacketListener packetlistener = this.packetListener;
+                    if (packetlistener != null) {
+                        ConnectionProtocol protocol = packetlistener.protocol();
+                        if (protocol == ConnectionProtocol.CONFIGURATION || protocol == ConnectionProtocol.PLAY) {
+                            // Neo: Always log critical network exceptions for config and play packets
+                            LOGGER.error("Exception caught in connection", p_129534_);
+                        }
+                    }
                     DisconnectionDetails disconnectiondetails;
                     if (packetlistener != null) {
                         disconnectiondetails = packetlistener.createDisconnectionInfo(component, p_129534_);
@@ -226,6 +_,7 @@
         if (p_320903_.flow() != this.getReceiving()) {
             throw new IllegalStateException("Invalid inbound protocol: " + p_320903_.id());
         } else {
+            this.inboundProtocol = p_320903_;
             this.packetListener = p_320940_;
             this.disconnectListener = null;
             UnconfiguredPipelineHandler.InboundConfigurationTask unconfiguredpipelinehandler$inboundconfigurationtask = UnconfiguredPipelineHandler.setupInboundProtocol(
@@ -254,7 +_,12 @@
             if (bundlerinfo != null) {
                 PacketBundleUnpacker packetbundleunpacker = new PacketBundleUnpacker(bundlerinfo);
                 unconfiguredpipelinehandler$outboundconfigurationtask = unconfiguredpipelinehandler$outboundconfigurationtask.andThen(
-                    p_319516_ -> p_319516_.pipeline().addAfter("encoder", "unbundler", packetbundleunpacker)
+                    p_319516_ -> {
+                        p_319516_.pipeline().addAfter("encoder", "unbundler", packetbundleunpacker);
+                        // Neo: our handlers must be between the encoder and the unbundler, so re-inject them
+                        // Note, this call must be inside the .andThen lambda, or it will actually run before the unbundler gets added.
+                        net.neoforged.neoforge.network.filters.NetworkFilters.injectIfNecessary(this);
+                    }
                 );
             }
 
@@ -316,12 +_,38 @@
         this.send(p_243248_, p_243316_, true);
     }
 
-    public void send(Packet<?> p_295839_, @Nullable PacketSendListener p_294866_, boolean p_294265_) {
-        if (this.isConnected()) {
-            this.flushQueue();
-            this.sendPacket(p_295839_, p_294866_, p_294265_);
+    public void send(Packet<?> packet, @Nullable PacketSendListener callbacks, boolean flush) {
+        // Paper start - Optimize network: Handle oversized packets better
+        final boolean connected = this.isConnected();
+        if (!connected) {
+            return;
+        }
+
+        if (connected && (InnerUtil.canSendImmediate(this, packet)
+                || (io.papermc.paper.util.MCUtil.isMainThread() && this.pendingActions.isEmpty()
+                && (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())))) {
+            this.sendPacket(packet, callbacks, flush);
         } else {
-            this.pendingActions.add(p_293706_ -> p_293706_.sendPacket(p_295839_, p_294866_, p_294265_));
+            // Write the packets to the queue, then flush - antixray hooks there already
+            final java.util.List<Packet<?>> extraPackets = InnerUtil.buildExtraPackets(packet);
+            final boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
+            if (!hasExtraPackets) {
+                this.pendingActions.add(new PacketSendAction(packet, callbacks, flush));
+            } else {
+                final java.util.List<PacketSendAction> actions = new java.util.ArrayList<>(1 + extraPackets.size());
+                actions.add(new PacketSendAction(packet, null, false)); // Delay the future listener until the end of the extra packets
+
+                for (int i = 0, len = extraPackets.size(); i < len;) {
+                    final Packet<?> extraPacket = extraPackets.get(i);
+                    final boolean end = ++i == len;
+                    actions.add(new PacketSendAction(extraPacket, end ? callbacks : null, end)); // Append listener to the end
+                }
+
+                this.pendingActions.addAll(actions);
+            }
+
+            this.flushQueue();
+            // Paper end - Optimize network
         }
     }
 
@@ -330,7 +_,7 @@
             this.flushQueue();
             p_294674_.accept(this);
         } else {
-            this.pendingActions.add(p_294674_);
+            this.pendingActions.add(new WrappedConsumer(p_294674_)); // Paper - Optimize network
         }
     }
 
@@ -344,6 +_,12 @@
     }
 
     private void doSendPacket(Packet<?> p_243260_, @Nullable PacketSendListener p_243290_, boolean p_294125_) {
+        // Paper start - Optimize network
+        final net.minecraft.server.level.ServerPlayer player = this.getPlayer();
+        if (!this.isConnected()) {
+            return;
+        }
+            // Paper end - Optimize network
         ChannelFuture channelfuture = p_294125_ ? this.channel.writeAndFlush(p_243260_) : this.channel.write(p_243260_);
         if (p_243290_ != null) {
             channelfuture.addListener(p_243167_ -> {
@@ -366,7 +_,7 @@
         if (this.isConnected()) {
             this.flush();
         } else {
-            this.pendingActions.add(Connection::flush);
+            this.pendingActions.add(new WrappedConsumer(Connection::flush)); // Paper - Optimize network
         }
     }
 
@@ -378,21 +_,77 @@
         }
     }
 
-    private void flushQueue() {
-        if (this.channel != null && this.channel.isOpen()) {
+    // Paper start - Optimize network: Rewrite this to be safer if ran off main thread
+    private boolean flushQueue() {
+        if (!this.isConnected()) {
+            return true;
+        }
+        if (io.papermc.paper.util.MCUtil.isMainThread()) {
+            return this.processQueue();
+        } else if (this.isPending) {
+            // Should only happen during login/status stages
             synchronized (this.pendingActions) {
-                Consumer<Connection> consumer;
-                while ((consumer = this.pendingActions.poll()) != null) {
-                    consumer.accept(this);
-                }
-            }
-        }
-    }
-
+                return this.processQueue();
+            }
+        }
+        return false;
+    }
+
+    private boolean processQueue() {
+        if (this.pendingActions.isEmpty()) {
+            return true;
+        }
+
+        // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
+        // But if we are not on main due to login/status, the parent is synchronized on packetQueue
+        final java.util.Iterator<WrappedConsumer> iterator = this.pendingActions.iterator();
+        while (iterator.hasNext()) {
+            final WrappedConsumer queued = iterator.next(); // poll -> peek
+
+            // Fix NPE (Spigot bug caused by handleDisconnection())
+            if (queued == null) {
+                return true;
+            }
+
+            if (queued.isConsumed()) {
+                continue;
+            }
+
+            iterator.remove();
+            if (queued.tryMarkConsumed()) {
+                queued.accept(this);
+            }
+        }
+        return true;
+    }
+    // Paper end - Optimize network
+
+    private static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper - Buffer joins to world
+    private static int joinAttemptsThisTick; // Paper - Buffer joins to world
+    private static int currTick; // Paper - Buffer joins to world
     public void tick() {
         this.flushQueue();
-        if (this.packetListener instanceof TickablePacketListener tickablepacketlistener) {
-            tickablepacketlistener.tick();
+        // Paper start - Buffer joins to world
+        if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
+            Connection.currTick = net.minecraft.server.MinecraftServer.currentTick;
+            Connection.joinAttemptsThisTick = 0;
+        }
+        // Paper end - Buffer joins to world
+        PacketListener packetlistener = this.packetListener;
+
+        if (packetlistener instanceof TickablePacketListener tickablepacketlistener) {
+            // Paper start - Buffer joins to world
+            if (!(this.packetListener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginPacketListener)
+                    || loginPacketListener.state != net.minecraft.server.network.ServerLoginPacketListenerImpl.State.VERIFYING
+                    || Connection.joinAttemptsThisTick++ < MAX_PER_TICK) {
+                // Paper start - detailed watchdog information
+                net.minecraft.network.protocol.PacketUtils.packetProcessing.push(this.packetListener);
+                try {
+                    tickablepacketlistener.tick();
+                } finally {
+                    net.minecraft.network.protocol.PacketUtils.packetProcessing.pop();
+                } // Paper end - detailed watchdog information
+            } // Paper end - Buffer joins to world
         }
 
         if (!this.isConnected() && !this.disconnectionHandled) {
@@ -400,7 +_,7 @@
         }
 
         if (this.channel != null) {
-            this.channel.flush();
+            if (enableExplicitFlush) this.channel.eventLoop().execute(() -> this.channel.flush()); // Paper - Disable explicit network manager flushing; we don't need to explicit flush here, but allow opt in incase issues are found to a better version
         }
 
         if (this.tickCount++ % 20 == 0) {
@@ -410,6 +_,7 @@
         if (this.bandwidthDebugMonitor != null) {
             this.bandwidthDebugMonitor.tick();
         }
+
     }
 
     protected void tickSecond() {
@@ -427,7 +_,7 @@
         if (this.address == null) {
             return "local";
         } else {
-            return p_295875_ ? this.address.toString() : "IP hidden";
+            return p_295875_ ? net.neoforged.neoforge.network.DualStackUtils.getAddressString(this.address) : "IP hidden";
         }
     }
 
@@ -436,12 +_,13 @@
     }
 
     public void disconnect(DisconnectionDetails p_350867_) {
+        this.clearPacketQueue(); // Paper - Optimize network
         if (this.channel == null) {
             this.delayedDisconnect = p_350867_;
         }
 
         if (this.isConnected()) {
-            this.channel.close().awaitUninterruptibly();
+            this.channel.close(); // We can't wait as this may be called from an event loop.
             this.disconnectionDetails = p_350867_;
         }
     }
@@ -470,6 +_,7 @@
     }
 
     public static ChannelFuture connect(InetSocketAddress p_290034_, boolean p_290035_, final Connection p_290031_) {
+        net.neoforged.neoforge.network.DualStackUtils.checkIPv6(p_290034_.getAddress());
         Class<? extends SocketChannel> oclass;
         EventLoopGroup eventloopgroup;
         if (Epoll.isAvailable() && p_290035_) {
@@ -613,7 +_,7 @@
     public void handleDisconnection() {
         if (this.channel != null && !this.channel.isOpen()) {
             if (this.disconnectionHandled) {
-                LOGGER.warn("handleDisconnection() called twice");
+                //LOGGER.warn("handleDisconnection() called twice");
             } else {
                 this.disconnectionHandled = true;
                 PacketListener packetlistener = this.getPacketListener();
@@ -624,6 +_,7 @@
                     );
                     packetlistener1.onDisconnect(disconnectiondetails);
                 }
+                this.clearPacketQueue(); // Paper - Optimize network
             }
         }
     }
@@ -639,4 +_,96 @@
     public void setBandwidthLogger(LocalSampleLogger p_323799_) {
         this.bandwidthDebugMonitor = new BandwidthDebugMonitor(p_323799_);
     }
+
+    public Channel channel() {
+        return this.channel;
+    }
+
+    public PacketFlow getDirection() {
+        return this.receiving;
+    }
+
+    public ProtocolInfo<?> getInboundProtocol() {
+        return Objects.requireNonNull(this.inboundProtocol, "Inbound protocol not set?");
+    }
+
+    // Paper start - Optimize network
+    public void clearPacketQueue() {
+        this.pendingActions.clear();
+    }
+
+    private static class InnerUtil { // Attempt to hide these methods from ProtocolLib, so it doesn't accidently pick them up.
+
+        @Nullable
+        private static java.util.List<Packet<?>> buildExtraPackets(final Packet<?> packet) {
+            final java.util.List<Packet<?>> extra = packet.getExtraPackets();
+            if (extra == null || extra.isEmpty()) {
+                return null;
+            }
+
+            final java.util.List<Packet<?>> ret = new java.util.ArrayList<>(1 + extra.size());
+            buildExtraPackets0(extra, ret);
+            return ret;
+        }
+
+        private static void buildExtraPackets0(final java.util.List<Packet<?>> extraPackets, final java.util.List<Packet<?>> into) {
+            for (final Packet<?> extra : extraPackets) {
+                into.add(extra);
+                final java.util.List<Packet<?>> extraExtra = extra.getExtraPackets();
+                if (extraExtra != null && !extraExtra.isEmpty()) {
+                    buildExtraPackets0(extraExtra, into);
+                }
+            }
+        }
+
+        private static boolean canSendImmediate(final Connection networkManager, final net.minecraft.network.protocol.Packet<?> packet) {
+            return networkManager.isPending || networkManager.packetListener.protocol() != ConnectionProtocol.PLAY ||
+                    packet instanceof net.minecraft.network.protocol.common.ClientboundKeepAlivePacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerChatPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSystemChatPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundCommandSuggestionsPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSetTitleTextPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSetSubtitleTextPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSetActionBarTextPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSetTitlesAnimationPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundClearTitlesPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSoundPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundSoundEntityPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundStopSoundPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket ||
+                    packet instanceof net.minecraft.network.protocol.game.ClientboundBossEventPacket;
+        }
+    }
+
+    private static class WrappedConsumer implements Consumer<Connection> {
+        private final Consumer<Connection> delegate;
+        private final java.util.concurrent.atomic.AtomicBoolean consumed = new java.util.concurrent.atomic.AtomicBoolean(false);
+
+        private WrappedConsumer(final Consumer<Connection> delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public void accept(final Connection connection) {
+            this.delegate.accept(connection);
+        }
+
+        public boolean tryMarkConsumed() {
+            return consumed.compareAndSet(false, true);
+        }
+
+        public boolean isConsumed() {
+            return consumed.get();
+        }
+    }
+
+    private static final class PacketSendAction extends WrappedConsumer {
+        private final Packet<?> packet;
+
+        private PacketSendAction(final Packet<?> packet, @Nullable final PacketSendListener packetSendListener, final boolean flush) {
+            super(connection -> connection.sendPacket(packet, packetSendListener, flush));
+            this.packet = packet;
+        }
+    }
+    // Paper end - Optimize network
 }
